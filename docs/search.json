[{"path":"index.html","id":"analyses-of-peatland-carbon-stocks","chapter":"1 Analyses of peatland carbon stocks","heading":"1 Analyses of peatland carbon stocks","text":"webpage describes data analyses behind manuscript (Fandrem et al. prep).web page buildin session:","code":"#> [1] \"2022-12-12 15:53:29 CET\"#> R version 4.1.2 (2021-11-01)\n#> Platform: x86_64-w64-mingw32/x64 (64-bit)\n#> Running under: Windows 10 x64 (build 19044)\n#> \n#> Matrix products: default\n#> \n#> locale:\n#> [1] LC_COLLATE=Norwegian Bokmål_Norway.1252 \n#> [2] LC_CTYPE=Norwegian Bokmål_Norway.1252   \n#> [3] LC_MONETARY=Norwegian Bokmål_Norway.1252\n#> [4] LC_NUMERIC=C                            \n#> [5] LC_TIME=Norwegian Bokmål_Norway.1252    \n#> \n#> attached base packages:\n#> [1] stats     graphics  grDevices utils     datasets \n#> [6] methods   base     \n#> \n#> loaded via a namespace (and not attached):\n#>  [1] bookdown_0.24   digest_0.6.29   R6_2.5.1       \n#>  [4] jsonlite_1.7.3  magrittr_2.0.2  evaluate_0.14  \n#>  [7] stringi_1.7.6   cachem_1.0.6    rlang_1.0.1    \n#> [10] cli_3.2.0       fs_1.5.2        rstudioapi_0.13\n#> [13] jquerylib_0.1.4 xml2_1.3.3      bslib_0.3.1    \n#> [16] rmarkdown_2.11  tools_4.1.2     stringr_1.4.0  \n#> [19] xfun_0.29       yaml_2.2.2      fastmap_1.1.0  \n#> [22] compiler_4.1.2  memoise_2.0.1   htmltools_0.5.2\n#> [25] downlit_0.4.0   knitr_1.37      sass_0.4.1"},{"path":"data.html","id":"data","chapter":"2 Data","heading":"2 Data","text":"","code":""},{"path":"data.html","id":"peat-depth-and-peatland-deliniation","chapter":"2 Data","heading":"2.1 Peat depth and peatland deliniation","text":"data comes five sites Norway. site shape file outline mire, csv file georeferenced peat depth measurementsImport shape files peatland delineations.Import peat depth measurements\nFigure 2.1: Confirming overlap shape file depth measurements\nDownload basemapsPlot static map\nFigure 2.2: Map Geilo Tydal test sites. peatland deliminated green polygon(s). Dots depth measurements Tydal colour size dots reflects measured peat depths meters.\ntest cases different. Geilo set several unique mire polygons. Usually, development project, one estimate peat volume C stock seperately, try now see can done one operation. Tydal typical example clear peatland delinination. cases dense peat depth measurements taken.","code":"\nlibrary(tmap)\nlibrary(sf)\n#> Linking to GEOS 3.9.1, GDAL 3.2.1, PROJ 7.2.1; sf_use_s2() is TRUE\nlibrary(readr)\nlibrary(tmaptools)\nlibrary(basemaps)\n#> Warning: package 'basemaps' was built under R version 4.1.3\nlibrary(ggplot2)\nlibrary(ggpubr)\n#> Warning: package 'ggpubr' was built under R version 4.1.3\nlibrary(gstat)\n#> Warning: package 'gstat' was built under R version 4.1.3\nlibrary(matrixStats)\n#> Warning: package 'matrixStats' was built under R version\n#> 4.1.3\nlibrary(ggtext)\n#> Warning: package 'ggtext' was built under R version 4.1.3\nlibrary(tidyverse)\n#> -- Attaching packages ------------------- tidyverse 1.3.1 --\n#> v tibble  3.1.6     v dplyr   1.0.8\n#> v tidyr   1.2.0     v stringr 1.4.0\n#> v purrr   0.3.4     v forcats 0.5.1\n#> -- Conflicts ---------------------- tidyverse_conflicts() --\n#> x dplyr::count()  masks matrixStats::count()\n#> x dplyr::filter() masks stats::filter()\n#> x dplyr::lag()    masks stats::lag()\nSHP_tydal <- sf::read_sf(\"Data/Tydal/stasjon_Setermyra.shp\")\nSHP_geilo  <- sf::read_sf(\"Data/Geilo/geilo-dybdef.shp\")\n\nst_crs(SHP_tydal)\n#> Coordinate Reference System:\n#>   User input: ETRS89 / UTM zone 33N \n#>   wkt:\n#> PROJCRS[\"ETRS89 / UTM zone 33N\",\n#>     BASEGEOGCRS[\"ETRS89\",\n#>         DATUM[\"European Terrestrial Reference System 1989\",\n#>             ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n#>                 LENGTHUNIT[\"metre\",1]]],\n#>         PRIMEM[\"Greenwich\",0,\n#>             ANGLEUNIT[\"degree\",0.0174532925199433]],\n#>         ID[\"EPSG\",4258]],\n#>     CONVERSION[\"UTM zone 33N\",\n#>         METHOD[\"Transverse Mercator\",\n#>             ID[\"EPSG\",9807]],\n#>         PARAMETER[\"Latitude of natural origin\",0,\n#>             ANGLEUNIT[\"degree\",0.0174532925199433],\n#>             ID[\"EPSG\",8801]],\n#>         PARAMETER[\"Longitude of natural origin\",15,\n#>             ANGLEUNIT[\"degree\",0.0174532925199433],\n#>             ID[\"EPSG\",8802]],\n#>         PARAMETER[\"Scale factor at natural origin\",0.9996,\n#>             SCALEUNIT[\"unity\",1],\n#>             ID[\"EPSG\",8805]],\n#>         PARAMETER[\"False easting\",500000,\n#>             LENGTHUNIT[\"metre\",1],\n#>             ID[\"EPSG\",8806]],\n#>         PARAMETER[\"False northing\",0,\n#>             LENGTHUNIT[\"metre\",1],\n#>             ID[\"EPSG\",8807]]],\n#>     CS[Cartesian,2],\n#>         AXIS[\"(E)\",east,\n#>             ORDER[1],\n#>             LENGTHUNIT[\"metre\",1]],\n#>         AXIS[\"(N)\",north,\n#>             ORDER[2],\n#>             LENGTHUNIT[\"metre\",1]],\n#>     USAGE[\n#>         SCOPE[\"Engineering survey, topographic mapping.\"],\n#>         AREA[\"Europe between 12Â°E and 18Â°E: Austria; Denmark - offshore and offshore; Germany - onshore and offshore; Norway including Svalbard - onshore and offshore.\"],\n#>         BBOX[46.4,12,84.01,18.01]],\n#>     ID[\"EPSG\",25833]]\nst_crs(SHP_geilo)# NA\n#> Coordinate Reference System: NA\n# I found CRS through trial and error \nst_crs(SHP_geilo) <- 25832 \n\n# Transform to UTM33N\nSHP_geilo <- st_transform(SHP_geilo, 25833)\ndepths_tydal <- readr::read_csv(\"Data/Tydal/Torvdybder_Tydal_stasjon.csv\")\ndepths_geilo <- read.csv(\"Data/Geilo/torvdybder.csv\", sep=\";\")\n\n\ndepths_tydal <- sf::st_as_sf(x = depths_tydal, \n                        coords = c(\"coords.x1\", \"coords.x2\"),\n                        crs = \"+init=epsg:25833\")\ndepths_geilo <- st_as_sf(x = depths_geilo, \n                        coords = c(\"x\", \"y\"),\n                        crs = \"+init=epsg:25832\")\ndepths_geilo <- st_transform(depths_geilo, 25833)\n# Confirm overlap. Using base plotting to avoid \n# auto-transformation\nplot(SHP_geilo$geometry,\n     col=\"red\"\n     )\nplot(depths_geilo$geometry, \n     pch = 16,\n     col=\"grey\",\n     cex=.1,\n     add=T)\n#OK\n# osmplotr want bboxes in latlong\nSHP_geilo_ll <- sf::st_transform(SHP_geilo, 4326)\nSHP_tydal_ll <- sf::st_transform(SHP_tydal, 4326)\n\nbb_Geilo <- sf::st_bbox(SHP_geilo_ll)\nbb_Tydal <- sf::st_bbox(SHP_tydal_ll)\n\n# GEILO\nbase_geilo_hw <- \n  osmplotr::extract_osm_objects(bbox = bb_Geilo,\n                                            key = c(\"highway\"),\n                                            sf = T)\nbase_geilo_building <- \n  osmplotr::extract_osm_objects(bbox = bb_Geilo,\n                                            key = c(\"building\"),\n                                            sf = T)\nbase_geilo_ww <- \n  osmplotr::extract_osm_objects(bbox = bb_Geilo,\n                                            key = c(\"waterway\"),\n                                            sf = T,\n                                            return_type = \"line\")\n\n# TYDAL\nbase_tydal_hw <- \n  osmplotr::extract_osm_objects(bbox = bb_Tydal,\n                                            key = \"highway\",\n                                            sf = T)\nbase_tydal_building <- \n  osmplotr::extract_osm_objects(bbox = bb_Tydal,\n                                            key = c(\"building\"),\n                                            sf = T)\nbase_tydal_ww <- \n  osmplotr::extract_osm_objects(bbox = bb_Tydal,\n                                            key = c(\"waterway\"),\n                                            sf = T,\n                                            return_type = \"line\")\n\n# GEILO\nstatic_geilo <- tm_shape(SHP_geilo_ll)+\n  tm_polygons(col=\"green\")+\ntm_shape(depths_geilo)+\n  tm_dots()+\ntm_shape(base_geilo_hw)+\n  tm_lines()+\ntm_shape(base_geilo_ww)+\n  tm_lines(col=\"blue\",\n           size=2)+\ntm_shape(base_geilo_building)+\n  tm_polygons(col=\"black\",\n              alpha = .3)+\ntm_compass()+\ntm_scale_bar()+\n  tm_layout(title=\"Geilo\")\n\n\n# TYDAL\nstatic_tydal <- tm_shape(SHP_tydal_ll)+\n  tm_polygons(col=\"green\")+\ntm_shape(depths_tydal)+\n  tm_dots(size=\"Dybde\",\n          col=\"Dybde\",\n          palette=\"-viridis\")+\ntm_shape(base_tydal_ww)+\n  tm_lines(col=\"blue\",\n           size=2)+\ntm_compass()+\ntm_scale_bar()+\ntm_layout(title=\"Tydal\",\n          legend.show = F,\n            inner.margins = c(.1,.02,.1,.02))\n\ntmap_arrange(static_geilo,\n             static_tydal)"},{"path":"find-best-model.html","id":"find-best-model","chapter":"3 Find best model","heading":"3 Find best model","text":"want interpolate values depth measurement raster grid. can estimate total volume peatland, also visualize depth profiles.main task chapter determination optimal power IDW cross validation","code":""},{"path":"find-best-model.html","id":"raster-grid","chapter":"3 Find best model","heading":"3.1 Raster grid","text":"Create raster grid based extent peatlandVisualise grid\nFigure 3.1: 1x1 m raster grid grey, overlayed peatland delineation yellow.\nCrop raster grid using peatland deliniation\nFigure 3.2: Preview cropped raster grids.\n","code":"\n#Create empty raster grid (stars object) based on the extent of the peatland shape files. Resolution 1 = 1 m (becasue crs is UTM)\ngrid_Tydal_stars <- starsExtra::make_grid(SHP_tydal, 1)\ngrid_Geilo_stars <- starsExtra::make_grid(SHP_geilo, 1)\n# To plot the grid we can convert the stars objects to sf. That way we can plot as polygons and visualise the individual cells.\n# This takes too long to perform for Geilo, but we can do it for Tydal:\ngrid_Tydal_sf <- st_as_sf(grid_Tydal_stars)\n\ntm_shape(grid_Tydal_sf)+\n  tm_polygons()+\n  tm_shape(SHP_tydal)+\n  tm_polygons(col=\"yellow\",\n              alpha=.5)\ngrid_Tydal_stars_crop <- sf::st_crop(grid_Tydal_stars, SHP_tydal)\ngrid_Geilo_stars_crop <- sf::st_crop(grid_Geilo_stars, SHP_geilo)\ntmap_arrange(\ntm_shape(grid_Geilo_stars_crop)+\n  tm_raster(palette = \"blue\")+\n  tm_layout(title = \"Geilo\",\n            legend.show = F),\ntm_shape(grid_Tydal_stars_crop)+\n  tm_raster(palette = \"red\")+\n  tm_layout(title = \"Tydal\",\n            legend.show = F))"},{"path":"find-best-model.html","id":"inverse-distance-weighting","chapter":"3 Find best model","heading":"3.2 Inverse distance weighting","text":"chose use IDW interpolation. want include separate step example calculating variogram, functions automatically fitting variogram seems unstable.IDW requires setting number neighboring points consider. set consider points dataset (default), increases calculation times also sensible general. use 9 nearest points, mean 8 closest points systematic grid around point included.IDW also power parameter, can tune results -weighting data points away. parameter needs optimized model. fit model power varying 0 10 explore model fit result chosen power.First, lets explore idw function parameters mean.\nTydal 4.4 meters ’s deepest point. Depending idw setting, prediction map closer number. example, consider closest neighbor, essentially performing nearest neighbor interpolation. choice power effect, deepest point prediction map equals deepest point measured data.keep power zero (ignore distance weighting) turn nmax 9, raster cell predicted mean nine closest points. overall predicted depth decreases.also include distance weighting, e.g. setting power =2, get smoothing points, local prediction power (.e. deepest point close true value).\nFigure 3.3: IDW different setting.\nincrease nmax 20, retain distance weighting, get slightly flatter (loss local) estimation nmax = 9.ramp nmax consider points dataset, little additional effect long positive power parameter.keep namx 9, ramp power, approach beginning, nearest neigbor inerolation.\nFigure 3.4: IDW different setting.\nexamples , power = 2 nmax = 9 probably best. However, don’t like little dots map. artefacts model, exist real. Therefore think prefer model slightly local focus. can increase power bit achieve .\nFigure 3.5: IDW relatively local focus.\nbit trial error, noticed nmax low 9, optimum power frequently became <2 (results model artefacts biased predictions can read ). therefore increase nmax.\nFigure 3.6: IDW relatively slightlly higher nmax higher power.\ntuning power parameter focus now.models look like.\nFigure 3.7: First view IDW models look like depending power parameter. Test site: Tydal.\nplotting Geilo include crosses depth measurements just many clutter image.\nFigure 3.8: First view IDW models look like depending power parameter. Test site: Geilo.\nlow power creates flat map depth measurements count equally predicted value. power set 0 just predict average measured peat depths. cases, increasing power beyond 4 little visual effect.","code":"\nnmax <- 9\ntemp <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_tydal, \n           newdata = grid_Tydal_stars_crop, \n           idp=0,\n           nmax = 1)\n#> [inverse distance weighted interpolation]\n\ntemp2 <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_tydal, \n           newdata = grid_Tydal_stars_crop, \n           idp=0,\n           nmax = 9)\n#> [inverse distance weighted interpolation]\n\ntemp3 <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_tydal, \n           newdata = grid_Tydal_stars_crop, \n           idp=2,\n           nmax = 9)\n#> [inverse distance weighted interpolation]\n\n\ntemp4 <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_tydal, \n           newdata = grid_Tydal_stars_crop, \n           idp=2,\n           nmax=20)\n#> [inverse distance weighted interpolation]\n\ntemp4.1 <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_tydal, \n           newdata = grid_Tydal_stars_crop, \n           idp=2)\n#> [inverse distance weighted interpolation]\n\ntemp5 <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_tydal, \n           newdata = grid_Tydal_stars_crop, \n           idp=100,\n           nmax = 9)\n#> [inverse distance weighted interpolation]\n\ngg_temp <- tm_shape(temp)+\n  tm_raster(col=\"var1.pred\",\n            title = \"\",\n            style = \"fixed\",\n              breaks = seq(0,5,1))+\n  tm_shape(depths_tydal)+\n  tm_symbols(shape = 4,\n             col = \"black\")+\n  tm_layout(legend.outside = F,\n            title = paste0(\"Power = 0\\nNmax = 1\"))\n\ngg_temp2 <- tm_shape(temp2)+\n  tm_raster(col=\"var1.pred\",\n            title = \"\",\n            style = \"fixed\",\n              breaks = seq(0,5,1))+\n  tm_shape(depths_tydal)+\n  tm_symbols(shape = 4,\n             col = \"black\")+\n  tm_layout(legend.outside = F,\n            title = paste0(\"Power = 0\\nNmax = 9\"))\n\ngg_temp3 <- tm_shape(temp3)+\n  tm_raster(col=\"var1.pred\",\n            title = \"\",\n            style = \"fixed\",\n              breaks = seq(0,5,1))+\n  tm_shape(depths_tydal)+\n  tm_symbols(shape = 4,\n             col = \"black\")+\n  tm_layout(legend.outside = F,\n            title = paste0(\"Power = 2\\nNmax = 9\"))\n\ngg_temp4 <- tm_shape(temp4)+\n  tm_raster(col=\"var1.pred\",\n            title = \"\",\n            style = \"fixed\",\n              breaks = seq(0,5,1))+\n  tm_shape(depths_tydal)+\n  tm_symbols(shape = 4,\n             col = \"black\")+\n  tm_layout(legend.outside = F,\n            title = paste0(\"Power = 2\\nNmax = 20\"))\n\ngg_temp4.1 <- tm_shape(temp4.1)+\n  tm_raster(col=\"var1.pred\",\n            title = \"\",\n            style = \"fixed\",\n              breaks = seq(0,5,1))+\n  tm_shape(depths_tydal)+\n  tm_symbols(shape = 4,\n             col = \"black\")+\n  tm_layout(legend.outside = F,\n            title = paste0(\"Power = 2\\nNmax = Inf\"))\n\ngg_temp5 <- tm_shape(temp5)+\n  tm_raster(col=\"var1.pred\",\n            title = \"\",\n            style = \"fixed\",\n              breaks = seq(0,5,1))+\n  tm_shape(depths_tydal)+\n  tm_symbols(shape = 4,\n             col = \"black\")+\n  tm_layout(legend.outside = F,\n            title = paste0(\"Power = 100\\nNmax = 9\"))\ntmap_arrange(gg_temp,\n             gg_temp2,\n             gg_temp3,\n             ncol = 3)\ntmap_arrange(gg_temp4,\n             gg_temp4.1,\n             gg_temp5,\n             ncol = 3)\ntemp <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_tydal, \n           newdata = grid_Tydal_stars_crop, \n           idp=4,\n           nmax = 9)\n#> [inverse distance weighted interpolation]\n\ntm_shape(temp)+\n  tm_raster(col=\"var1.pred\",\n            title = \"\",\n            style = \"fixed\",\n              breaks = seq(0,5,1))+\n  tm_shape(depths_tydal)+\n  tm_symbols(shape = 4,\n             col = \"black\")+\n  tm_layout(legend.outside = T,\n            title = paste0(\"Power = 4\\nNmax = 9\"))\ntemp <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_tydal, \n           newdata = grid_Tydal_stars_crop, \n           idp=5,\n           nmax = 20)\n#> [inverse distance weighted interpolation]\n\ntm_shape(temp)+\n  tm_raster(col=\"var1.pred\",\n            title = \"\",\n            style = \"fixed\",\n              breaks = seq(0,5,1))+\n  tm_shape(depths_tydal)+\n  tm_symbols(shape = 4,\n             col = \"black\")+\n  tm_layout(legend.outside = T,\n            title = paste0(\"Power = 4\\nNmax = 20\"))\nnmax <- 20\nmyPowers <- c(0:10)\nfor(i in myPowers){\n  temp <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_tydal, \n           newdata = grid_Tydal_stars_crop, \n           idp=i,\n           nmax = nmax)\n  assign(paste0(\"IDW_tydal_\", i), temp)\n}\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n\n# this one takes a couple of minutes to run\nfor(i in myPowers){\n  temp <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_geilo, \n           newdata = grid_Geilo_stars_crop, \n           idp=i)\n  assign(paste0(\"IDW_geilo_\", i), temp)\n}\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\nfor(i in myPowers){\n  \n  temp <- get(paste0(\"IDW_tydal_\", i))\n  \n  temp <- tm_shape(temp)+\n    tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Interpolated peat\\ndepth (m)\")+\n    tm_layout(legend.outside = T,\n            title = paste0(\"Power = \", i))+\n    tm_shape(depths_tydal)+\n    tm_symbols(col=\"black\",\n               shape=4,\n               size = .5)\n  assign(paste0(\"tmap_IDW_tydal_power_\", i), temp)\n}\n\n\n\ntmap_arrange(\n  tmap_IDW_tydal_power_0,\n  tmap_IDW_tydal_power_1,\n  tmap_IDW_tydal_power_2,\n  tmap_IDW_tydal_power_4,\n  tmap_IDW_tydal_power_6,\n  tmap_IDW_tydal_power_8,\nncol = 3)\nfor(i in myPowers){\n  \n  temp <- get(paste0(\"IDW_geilo_\", i))\n  \n  temp <- tm_shape(temp)+\n    tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Interpolated peat\\ndepth (m)\")+\n    tm_layout(legend.outside = T,\n            title = paste0(\"Power = \", i))\n  assign(paste0(\"tmap_IDW_geilo_power_\", i), temp)\n}\n\n\n\ntmap_arrange(\n  #tmap_IDW_geilo_power_0,\n  tmap_IDW_geilo_power_1,\n  tmap_IDW_geilo_power_2,\n  tmap_IDW_geilo_power_4,\n  #tmap_IDW_geilo_power_6,\n  #tmap_IDW_geilo_power_8,\nncol = 1)"},{"path":"find-best-model.html","id":"original-residuals","chapter":"3 Find best model","heading":"3.3 Original residuals","text":"Let’s check fit plot residuals.\nFigure 3.9: Residuals (observed - predicted) stabelize power greater 2.\npower 2 greater, residuals stable unbiased (centered 0).","code":"\n# Prepare data frame with the measured data\nresids_tydal <- data.frame(ID = 1:nrow(depths_tydal))\nresids_geilo <- data.frame(ID = 1:nrow(depths_geilo))\n\nresids_tydal$measured <- depths_tydal$Dybde\nresids_geilo$measured <- depths_geilo$Dybde\n\n# Get the predicted values\nfor(i in myPowers){\n  temp <- get(paste0(\"IDW_tydal_\", i))\n  fit  <- stars::st_extract(temp, depths_tydal)\n  resids_tydal[,i+3] <- resids_tydal$measured-fit$var1.pred\n}\n\nfor(i in myPowers){\n  temp <- get(paste0(\"IDW_geilo_\", i))\n  fit  <- stars::st_extract(temp, depths_geilo)\n  resids_geilo[,i+3] <- resids_geilo$measured-fit$var1.pred\n}\n\n# Lots of NA's produced for depth measurements taken outside the peatland polygons\n#tmap_mode(\"plot\")\n#tm_shape(IDW_geilo_10)+\n#  tm_raster(col=\"var1.pred\")+\n#  tm_shape(fit[is.na(fit$var1.pred),])+\n#  tm_symbols(size = .1,\n#             col=\"yellow\")\n\nresids_geilo <- resids_geilo[!is.na(resids_geilo$V3),]\n\n\nresids_tydal <- tidyr::pivot_longer(resids_tydal,\n                                    !ID&!measured,\n                                    names_to = \"power\",\n                                    values_to = \"residual\")\nresids_geilo <- tidyr::pivot_longer(resids_geilo,\n                                    !ID&!measured,\n                                    names_to = \"power\",\n                                    values_to = \"residual\")\n\n\n# Remove V from column names\nresids_tydal$power <- gsub(pattern = \"V\", \n                           replacement = \"\",\n                           x = resids_tydal$power)\nresids_geilo$power <- gsub(pattern = \"V\", \n                           replacement = \"\",\n                           x = resids_geilo$power)\n\nresids_tydal$power <- as.numeric(resids_tydal$power)\nresids_geilo$power <- as.numeric(resids_geilo$power)\n\nresids_tydal$power <- resids_tydal$power-3\nresids_geilo$power <- resids_geilo$power-3\n\n\ngg_resids_tydal <- \n  ggplot(resids_tydal, aes(x=factor(power), y = residual))+\n  geom_boxplot(fill=\"grey\",\n              trim=F)+\n  theme_bw(base_size = 12)+\n  xlab(\"Power\")+\n  ggtitle(\"Tydal\")\n#> Warning: Ignoring unknown parameters: trim\n\n\ngg_resids_geilo <- \n  ggplot(resids_geilo, aes(x=factor(power), y = residual))+\n  geom_boxplot(fill=\"grey\",\n              trim=F)+\n  theme_bw(base_size = 12)+\n  xlab(\"Power\")+\n  ggtitle(\"Geilo\")\n#> Warning: Ignoring unknown parameters: trim\nggpubr::ggarrange(gg_resids_geilo,\n                  gg_resids_tydal)"},{"path":"find-best-model.html","id":"estimated-volume","chapter":"3 Find best model","heading":"3.4 Estimated volume","text":"estimated volume - change depending power setting? Note data projected UTM, mean depth (meter) 1x1 raster cell equals volumne m3.\nFigure 3.10: Peat volume estimates function power parameter.\nvalues stabilizing relatively fast, power less 3 seem like bad idea. general though, difference worst best models just 2-4%.relationship probably depends bit number data points density peat depth measurements. generalise just yet.","code":"\nvolume_tydal <- NULL\nfor(i in myPowers){\n  temp <- get(paste0(\"IDW_tydal_\", i))\n  volume_tydal <- c(volume_tydal,\n                    sum(temp$var1.pred, na.rm = T))\n}\n\n\nvolume_geilo <- NULL\nfor(i in myPowers){\n  temp <- get(paste0(\"IDW_geilo_\", i))\n  volume_geilo <- c(volume_geilo,\n                    sum(temp$var1.pred, na.rm = T))\n}\nvolume_tydal <- data.frame(\"volume\" = volume_tydal,\n                              \"power\" = myPowers)\nvolume_tydal$relative_volume <- volume_tydal$volume/mean(volume_tydal$volume)*100\n\nvolume_geilo <- data.frame(\"volume\" = volume_geilo,\n                              \"power\" = myPowers)\nvolume_geilo$relative_volume <- volume_geilo$volume/mean(volume_geilo$volume)*100\n\n\ngg_predVolume_tydal <- \n  ggplot(volume_tydal, aes(x = factor(power), y = relative_volume))+\n  geom_point(size=10)+\n  xlab(\"power\")+\n  ylab(\"Peat volume as a percentage of\\nmean predicted peat volume\")+\n  theme_bw(base_size = 12)+\n  ggtitle(\"Tydal\")\n\ngg_predVolume_geilo <- \n  ggplot(volume_geilo, aes(x = factor(power), y = relative_volume))+\n  geom_point(size=10)+\n  xlab(\"power\")+\n  ylab(\"Peat volume as a percentage of\\nmean predicted peat volume\")+\n  theme_bw(base_size = 12)+\n  ggtitle(\"Geilo\")\n\nggpubr::ggarrange(\n  gg_predVolume_geilo,\n  gg_predVolume_tydal\n)"},{"path":"find-best-model.html","id":"model-fit-loocv","chapter":"3 Find best model","heading":"3.5 Model fit LOOCV","text":"Now let’s proper test model fit, using leave one cross validation. use mean absolute deviation measure model fit.\nFigure 3.11: Mean absolute error based leave-one-cross validation. optimal power setting indicated green star symbol.\nmean absolute error negligible two cases. interpretation , leave one peat depth measurement predict peat depth point (using just remaining data points) models average 40-60 cm wrong.best models power = 2 Geilo 4 Tydal. models also look reasonable terms predicted peat volume spread raw residuals (see ). map Geilo quite spotted, perhaps higher power smart. estimate peat volume polygon separately.power less 2 recommended seen . nmax set 9, optimum power Geilo actually 1. therefore went back script increased nmax 20.","code":"\nMAE_tydal <- data.frame(power = myPowers,\n                        MAE = as.numeric(NA))\nfor(i in myPowers){\n  temp <- krige.cv(Dybde ~ 1, depths_tydal, set = list(idp=i), nmax = nmax)\n  MAE_tydal$MAE[MAE_tydal$power==i] <- mean(abs(temp$residual))\n}\n\nMAE_tydal$best <- ifelse(MAE_tydal$MAE==min(MAE_tydal$MAE), \"best\", \"not-best\")\n\n\n# For Geilo the calculations take longer, so I will not consider as big a range in power\n# This part still takes 2 min on my computer, so I will run it once and cache it on a local server.\nmyPowers2 <- seq(0,5,1)\n#MAE_geilo <- data.frame(power = myPowers2,\n#                        MAE = as.numeric(NA))\n#for(i in myPowers2){\n#  temp <- krige.cv(Dybde ~ 1, depths_geilo, set = list(idp=i), nmax = nmax)\n#  MAE_geilo$MAE[MAE_geilo$power==i] <- mean(abs(temp$residual))\n#}\n#\n#MAE_geilo$best <- ifelse(MAE_geilo$MAE==min(MAE_geilo$MAE), \"best\", \"not-best\")\n#saveRDS(MAE_geilo, \"Data/cache/MAE_geilo_cashe.rds\")\nMAE_geilo <- readRDS(\"Data/cache/MAE_geilo_cashe.rds\")\ngg_MAE_tydal <- ggplot(MAE_tydal, aes(x = power, y = MAE,\n                      colour = best,\n                      shape = best))+\n  geom_point(size=10)+\n  theme_bw(base_size = 12)+\n  scale_x_continuous(breaks = myPowers)+\n  guides(colour=\"none\",\n         shape = \"none\")+\n  scale_color_manual(values = c(\"darkgreen\",\"grey\"))+\n  scale_shape_manual(values = c(18, 19))+\n  ggtitle(\"Tydal\")\n\ngg_MAE_geilo <- ggplot(MAE_geilo, aes(x = power, y = MAE,\n                      colour = best,\n                      shape = best))+\n  geom_point(size=10)+\n  theme_bw(base_size = 12)+\n  scale_x_continuous(breaks = myPowers2)+\n  guides(colour=\"none\",\n         shape = \"none\")+\n  scale_color_manual(values = c(\"darkgreen\",\"grey\"))+\n  scale_shape_manual(values = c(18, 19))+\n  ggtitle(\"Geilo\")\n\nggpubr::ggarrange(gg_MAE_geilo,\n                  gg_MAE_tydal)"},{"path":"find-best-model.html","id":"best-models","chapter":"3 Find best model","heading":"3.6 Best models","text":"Based criterion lowest MAE identified best IDW models two test sites:\nFigure 3.12: Best model estimating peat depth profile Tydal test site. Dots indicatore peat depth sampling points. MAE = 0.59 meters. Power = 4.\n\nFigure 3.13: Best model estimating peat depth profile Geilo test site. Dots indicatore peat depth sampling points. MAE = 0.4 meters. Power = 2.\nTydal 7.7336967^{4} m3 Geilo 1.0226839^{5} m3. can get residuals LOOCV.\nFigure 3.14: Resuduals LOOCV. Test site: Tydal\npoint inside prediction area, assume error equal mean residual LOOCV. Tydal, 0.59 meters. clear way predict confidence intervals IDW. residuals, MAE, represnets uncertainty grid cell value, uncertainty sum grid cells. Since mean residuals (absolute mean, normal mean) quite close 0, uncertainty cell cancels .can calculate peat volume based best model\nFigure 3.15: Peat volume estimated IDW. Errors volumes calculated multiplying predicted values mean absolute error LOOCV.\nrough volume (iDW) Tydal GeiloNext want try estimate many depth measurement need get stable result, therms peat volume visual appearance. also see choice power parameter still best removing data points.","code":"\ntm_tydal <- tm_shape(IDW_tydal_4)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Interpolated peat\\ndepth (m)\")+\n  tm_shape(depths_tydal)+\n  tm_symbols(shape=4,\n             col=\"black\",\n             size=.5)+\n  tm_compass(type=\"8star\", position = c(\"right\", \"bottom\"), size = 2) +\n  tm_scale_bar(position = c(\"left\", \"bottom\"), width = 0.3)+\n  tm_layout(inner.margins = c(0.15, 0.05, 0, 0.05),\n            legend.outside = T)\n\n#tmap::tmap_save(tm_tydal,\n#                \"Output/plot_IDW_tydal_bestModel.tiff\",\n#                 width = 1600, height = 1600, units = \"px\")\ntm_tydal\nIDW_geilo_2 <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_geilo, \n           newdata = grid_Geilo_stars_crop, \n           idp=2,\n           nmax = nmax)\ntm_geilo <- \n  tm_shape(IDW_geilo_2)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Interpolated peat\\ndepth (m)\")+\n  tm_compass(type=\"8star\", position = c(\"right\", \"bottom\"), size = 2) +\n  tm_scale_bar(position = c(\"right\", \"bottom\"), width = 0.3)\n\n#tmap::tmap_save(tm_geilo,\n#                \"Output/plot_IDW_geilo_bestModel.tiff\",\n#                 width = 1600, height = 1600, units = \"px\")\ntm_geilo\n#> stars object downsampled to 1369 by 730 cells. See tm_shape manual (argument raster.downsample)\nSE_tydal <- krige.cv(Dybde ~ 1, depths_tydal, set = list(idp=4), nmax = nmax)\nSE_geilo <- krige.cv(Dybde ~ 1, depths_geilo, set = list(idp=2), nmax = nmax)\n\n\nggplot(SE_tydal, aes(x = residual))+\n  geom_histogram()\nvolume <- data.frame(site = c(\"Tydal\", \"Geilo\"),\n                     volume = c(sum(IDW_tydal_4$var1.pred, na.rm = T),\n                                sum(IDW_geilo_2$var1.pred, na.rm = T)))\nlibrary(ggtext) # write superscript as markdown\nggplot(volume, aes(x = site, y = volume))+\n  geom_bar(stat=\"identity\",\n           colour=\"black\",\n           fill = \"grey\")+\n  theme_bw(base_size = 12)+\n  theme(axis.title.y = element_markdown())+\n  ylab(\"Volume m^(3)\")\nSHP_tydal$myArea <- sf::st_area(SHP_tydal)\nmean(depths_tydal$Dybde)*sum(SHP_tydal$myArea)\n#> 76994.27 [m^2]\nSHP_geilo$myArea <- sf::st_area(SHP_geilo)\nmean(depths_geilo$Dybde)*sum(SHP_geilo$myArea)\n#> 98690.12 [m^2]"},{"path":"optimise-sampling-intensity.html","id":"optimise-sampling-intensity","chapter":"4 Optimise sampling intensity","heading":"4 Optimise sampling intensity","text":"Now want resample reduce dataset, try keep original sampling design.\nGeilo dataset want limit part analyses consider one polygon. obvious peat depth measurement neighboring mire replace data collection actuall mire.","code":""},{"path":"optimise-sampling-intensity.html","id":"subset-geilo-data","chapter":"4 Optimise sampling intensity","heading":"4.1 Subset Geilo data","text":"\nFigure 4.1: Peat depth measurements biggest Geilo mires.\nLooking depth measurements figure , reminded data contains zeros (measurements taken near edge) truncated 3 (length peat depth probe).\nFigure 4.2: One mire polygon Geilo test site used assessment minimum sampling.\n","code":"\n# select a single mire polygon\nSHP_geilo_biggest <- SHP_geilo[which.max(SHP_geilo$AREAL),]\n\n# drop the depth measurements from the other polygons\ndepths_geilo_biggest <- sf::st_intersection(depths_geilo, SHP_geilo_biggest)\n\n#Crop the raster grid\ngrid_Geilo_stars_crop_biggest <- sf::st_crop(grid_Geilo_stars, SHP_geilo_biggest)\nplot(depths_geilo_biggest$Dybde[order(depths_geilo_biggest$Dybde)],\n     ylab=\"Peat depth (m)\")\ntm_shape(SHP_geilo_biggest)+\n  tm_polygons()+\n  tm_shape(depths_geilo_biggest)+\n  tm_symbols(col=\"black\",\n             shape=4)"},{"path":"optimise-sampling-intensity.html","id":"repeat-the-best-idw","chapter":"4 Optimise sampling intensity","heading":"4.2 Repeat the best IDW","text":"simply recalculate best models, described previous chapter","code":"\nIDW_tydal_4 <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_tydal, \n           newdata = grid_Tydal_stars_crop, \n           idp=4,\n           nmax = nmax)\n#> [inverse distance weighted interpolation]\n\nIDW_geilo_2 <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_geilo_biggest, \n           newdata = grid_Geilo_stars_crop_biggest, \n           idp=2,\n           nmax = nmax)\n#> [inverse distance weighted interpolation]"},{"path":"optimise-sampling-intensity.html","id":"reduce-n","chapter":"4 Optimise sampling intensity","heading":"4.3 Reduce N","text":"gradually removing closest point.First need set temporary files -loop.Create temporary working filesGet summed volumeGet median, mean skewness distances closest neighborGet MAEPut dataframePerform -loop gradually remove points based close points. hopefully retain systematic design points (avoiding clumping points).Import data back inA code block just getting reduced datasets\n(#fig:sampling_reduction)Demonstrating gradual reduction sampling points. removing 80 data points, median distance points 28 meters. Test site: Tydal\n\n(#fig:sampling_reduction_geilo)Demonstrating gradual reduction sampling points. removinf 200 data poins, median distance points 19 meters. Test site: Geilo\n","code":"\ndistMatrix_tydal <- sf::st_distance(depths_tydal) \ndistMatrix_tydal <- units::drop_units(distMatrix_tydal)\ndistMatrix_tydal[distMatrix_tydal == 0] <- NA\ndistMin_tydal <- matrixStats::rowMins(distMatrix_tydal, na.rm=T)\n\ndistMatrix_geilo <- sf::st_distance(depths_geilo_biggest) \ndistMatrix_geilo <- units::drop_units(distMatrix_geilo)\ndistMatrix_geilo[distMatrix_geilo == 0] <- NA\ndistMin_geilo <- matrixStats::rowMins(distMatrix_geilo, na.rm=T)\ndistMin_tydal_temp <- distMin_tydal\ndepths_tydal_temp <- depths_tydal\n\ndistMin_geilo_temp <- distMin_geilo\ndepths_geilo_temp <- depths_geilo_biggest\nest_tydal <- sum(IDW_tydal_4$var1.pred, na.rm=T)\nest_geilo <- sum(IDW_geilo_2$var1.pred, na.rm=T)\nmedianDist_tydal <- median(distMin_tydal)\nmeanDist_tydal <- mean(distMin_tydal)\nskewDist_tydal <- e1071::skewness(distMin_tydal)\n\nmedianDist_geilo <- median(distMin_geilo)\nmeanDist_geilo <- mean(distMin_geilo)\nskewDist_geilo <- e1071::skewness(distMin_geilo)\nMAE_tydal_allData <- krige.cv(Dybde ~ 1, depths_tydal, set = list(idp=4), nmax = nmax)\nMAE_tydal_allData <- mean(abs(MAE_tydal_allData$residual))\n\nMAE_geilo_allData <- krige.cv(Dybde ~ 1, depths_geilo_biggest, set = list(idp=2), nmax = nmax)\nMAE_geilo_allData <- mean(abs(MAE_geilo_allData$residual))\nsummaryTable_tydal <- data.frame(\n  medianDist             = medianDist_tydal,\n  meanDist               = meanDist_tydal,\n  skewness               = skewDist_tydal,\n  n                      = length(distMin_tydal),\n  estimatedPeatVolume_m3 = est_tydal,\n  MAE                    = MAE_tydal_allData\n)\n\nsummaryTable_geilo <- data.frame(\n  medianDist             = medianDist_geilo,\n  meanDist               = meanDist_geilo,\n  skewness               = skewDist_geilo,\n  n                      = length(distMin_geilo),\n  estimatedPeatVolume_m3 = est_geilo,\n  MAE                    = MAE_geilo_allData\n)\n# I will not bother going lower than ten data points\nfor(i in 1:c(nrow(depths_tydal)-10)){\n  \n print(paste(\"run number = \", i))\n  \n toRemove <- which(distMin_tydal_temp == min(distMin_tydal_temp))[1]\n print(paste(\"Removing row number \", toRemove))\n \n # get some stats distance between neighbours\n medianDist <- median(distMin_tydal_temp)\n meanDist   <- mean(distMin_tydal_temp)\n skewDist   <- e1071::skewness(distMin_tydal_temp)\n\n depths_tydal_temp <- depths_tydal_temp[-toRemove,]\n\n # perform interpolation on tempDF\n  int <- gstat::idw(Dybde ~ 1, depths_tydal_temp, \n                    newdata=grid_Tydal_stars_crop, \n                    nmax=nmax, idp=4)\n  \n  # Export some predictions for checks\n  if(i %in% seq(30, 90, 30)){\n    assign(paste0(\"IDW_tydal_i\", i), int)\n  }\n  \n  \n  est <- sum(int$var1.pred, na.rm=T)\n  \n  # get the MAE as well, even though it takes a long time to run\n  MAE <- krige.cv(Dybde ~ 1, depths_tydal_temp, set = list(idp=4), nmax = nmax)\n  MAE <- mean(abs(MAE$residual))\n  \n # paste into the summary table\n summaryTable_tydal[1+i,\"medianDist\"]      <- medianDist\n summaryTable_tydal[1+i,\"meanDist\"]        <- meanDist\n summaryTable_tydal[1+i,\"skewness\"]        <- skewDist\n summaryTable_tydal[1+i,\"n\"]               <- length(distMin_tydal_temp)-1\n summaryTable_tydal[1+i,\"estimatedPeatVolume_m3\"]           <- est\n summaryTable_tydal[1+i,\"MAE\"]             <- MAE\n\n \n  # prepare dataset for next loop\n euclidDist <- sf::st_distance(depths_tydal_temp) \n euclidDist <- units::drop_units(euclidDist)\n euclidDist[euclidDist == 0] <- NA\n distMin_tydal_temp <- rowMins(euclidDist, na.rm=T)\n \n}\nsaveRDS(summaryTable_tydal, \"Data/Tydal/tydal_cvAnalysisData.rds\")\n\nsaveRDS(IDW_tydal_i30, \"Output/Tydal/IDW_tydal_i30.rds\")\nsaveRDS(IDW_tydal_i60, \"Output/Tydal/IDW_tydal_i60.rds\")\nsaveRDS(IDW_tydal_i90, \"Output/Tydal/IDW_tydal_i90.rds\")\n# I will not bother going lower than ten data points\nfor(i in 1:c(nrow(depths_geilo_biggest)-10)){\n  \n print(paste(\"run number = \", i))\n  \n toRemove <- which(distMin_geilo_temp == min(distMin_geilo_temp))[1]\n print(paste(\"Removing row number \", toRemove))\n \n # get some stats distance between neighbours\n medianDist <- median(distMin_geilo_temp)\n meanDist   <- mean(distMin_geilo_temp)\n skewDist   <- e1071::skewness(distMin_geilo_temp)\n\n depths_geilo_temp <- depths_geilo_temp[-toRemove,]\n\n # perform interpolation on tempDF\n  int <- gstat::idw(Dybde ~ 1, depths_geilo_temp, \n                    newdata=grid_Geilo_stars_crop_biggest, \n                    nmax=nmax, idp=2)\n  \n  # Export some predictions for checks\n  if(i %in% seq(40, 240, 50)){\n    assign(paste0(\"IDW_geilo_i\", i), int)\n  }\n  \n  \n  est <- sum(int$var1.pred, na.rm=T)\n  \n  # get the MAE as well, even though it takes a long time to run\n  MAE <- krige.cv(Dybde ~ 1, depths_geilo_temp, set = list(idp=2), nmax = nmax)\n  MAE <- mean(abs(MAE$residual))\n  \n # paste into the summary table\n summaryTable_geilo[1+i,\"medianDist\"]      <- medianDist\n summaryTable_geilo[1+i,\"meanDist\"]        <- meanDist\n summaryTable_geilo[1+i,\"skewness\"]        <- skewDist\n summaryTable_geilo[1+i,\"n\"]               <- length(distMin_geilo_temp)-1\n summaryTable_geilo[1+i,\"estimatedPeatVolume_m3\"]           <- est\n summaryTable_geilo[1+i,\"MAE\"]             <- MAE\n\n \n  # prepare dataset for next loop\n euclidDist <- sf::st_distance(depths_geilo_temp) \n euclidDist <- units::drop_units(euclidDist)\n euclidDist[euclidDist == 0] <- NA\n distMin_geilo_temp <- rowMins(euclidDist, na.rm=T)\n \n}\nsaveRDS(summaryTable_geilo, \"Data/Geilo/geilo_cvAnalysisData.rds\")\n\nsaveRDS(IDW_geilo_i40, \"Output/Geilo/IDW_geilo_i40.rds\")\nsaveRDS(IDW_geilo_i90, \"Output/Geilo/IDW_geilo_i90.rds\")\nsaveRDS(IDW_geilo_i140, \"Output/Geilo/IDW_geilo_i140.rds\")\nsaveRDS(IDW_geilo_i190, \"Output/Geilo/IDW_geilo_i190.rds\")\nsaveRDS(IDW_geilo_i240, \"Output/Geilo/IDW_geilo_i240.rds\")\nsummaryTable_tydal <- readRDS(\"Data/Tydal/tydal_cvAnalysisData.rds\")\nsummaryTable_geilo <- readRDS(\"Data/Geilo/geilo_cvAnalysisData.rds\")\ndistMin_tydal_temp <- distMin_tydal\ndepths_tydal_temp <- depths_tydal\n\nfor(i in 1:c(nrow(depths_tydal)-10)){\n  \n #print(paste(\"run number = \", i))\n  \n toRemove <- which(distMin_tydal_temp == min(distMin_tydal_temp))[1]\n #print(paste(\"Removing row number \", toRemove))\n \n depths_tydal_temp <- depths_tydal_temp[-toRemove,]\n\n  # Export some data set for checks\n  if(i %in% seq(30, 90, 10)){\n    assign(paste0(\"depths_tydal_i\", i), depths_tydal_temp)\n  }\n\n \n  # prepare dataset for next loop\n euclidDist <- sf::st_distance(depths_tydal_temp) \n euclidDist <- units::drop_units(euclidDist)\n euclidDist[euclidDist == 0] <- NA\n distMin_tydal_temp <- rowMins(euclidDist, na.rm=T)\n \n}\n\n\n\n#### Geilo\n\ndistMin_geilo_temp <- distMin_geilo\ndepths_geilo_temp <- depths_geilo_biggest\n\nfor(i in 1:c(nrow(depths_geilo_biggest)-10)){\n  \n #print(paste(\"run number = \", i))\n  \n toRemove <- which(distMin_geilo_temp == min(distMin_geilo_temp))[1]\n #print(paste(\"Removing row number \", toRemove))\n \n depths_geilo_temp <- depths_geilo_temp[-toRemove,]\n\n  # Export some data set for checks\n  if(i %in% c(1, 50, 100, 200)){\n    assign(paste0(\"depths_geilo_i\", i), depths_geilo_temp)\n  }\n\n \n  # prepare dataset for next loop\n euclidDist <- sf::st_distance(depths_geilo_temp) \n euclidDist <- units::drop_units(euclidDist)\n euclidDist[euclidDist == 0] <- NA\n distMin_geilo_temp <- rowMins(euclidDist, na.rm=T)\n \n}\ntmap_arrange(\ntm_shape(SHP_tydal)+\n  tm_polygons()+\n  tm_shape(depths_tydal)+\n  tm_symbols(col=\"black\",\n               shape=4,\n               size = .5)+\n  tm_layout(title = \"All data points\",\n            inner.margins = c(.1,.02,.1,.02))\n,\ntm_shape(SHP_tydal)+\n  tm_polygons()+\n  tm_shape(depths_tydal_i30)+\n  tm_symbols(col=\"black\",\n               shape=4,\n               size = .5)+\n  tm_layout(title = \"-30 data points\",\n            inner.margins = c(.1,.02,.1,.02))\n,\ntm_shape(SHP_tydal)+\n  tm_polygons()+\n  tm_shape(depths_tydal_i60)+\n  tm_symbols(col=\"black\",\n               shape=4,\n               size = .5)+\n  tm_layout(title = \"-60 data points\",\n            inner.margins = c(.1,.02,.1,.02))\n,\ntm_shape(SHP_tydal)+\n  tm_polygons()+\n  tm_shape(depths_tydal_i80)+\n  tm_symbols(col=\"black\",\n               shape=4,\n               size = .5)+\n  tm_layout(title = \"-80 data points\",\n            inner.margins = c(.1,.02,.1,.02)))\ntmap_arrange(\ntm_shape(SHP_geilo_biggest)+\n  tm_polygons()+\n  tm_shape(depths_geilo_biggest)+\n  tm_symbols(col=\"black\",\n               shape=4,\n               size = .5)+\n  tm_layout(title = \"All data points\",\n            inner.margins = c(.1,.02,.1,.02))\n,\ntm_shape(SHP_geilo_biggest)+\n  tm_polygons()+\n  tm_shape(depths_geilo_i50)+\n  tm_symbols(col=\"black\",\n               shape=4,\n               size = .5)+\n  tm_layout(title = \"-50 data points\",\n            inner.margins = c(.1,.02,.1,.02))\n,\ntm_shape(SHP_geilo_biggest)+\n  tm_polygons()+\n  tm_shape(depths_geilo_i100)+\n  tm_symbols(col=\"black\",\n               shape=4,\n               size = .5)+\n  tm_layout(title = \"-100 data points\",\n            inner.margins = c(.1,.02,.1,.02))\n,\ntm_shape(SHP_geilo_biggest)+\n  tm_polygons()+\n  tm_shape(depths_geilo_i200)+\n  tm_symbols(col=\"black\",\n               shape=4,\n               size = .5)+\n  tm_layout(title = \"-200 data points\",\n            inner.margins = c(.1,.02,.1,.02)))"},{"path":"optimise-sampling-intensity.html","id":"explore-results","chapter":"4 Optimise sampling intensity","heading":"4.4 Explore results","text":"","code":""},{"path":"optimise-sampling-intensity.html","id":"sampling-design","chapter":"4 Optimise sampling intensity","heading":"4.4.1 Sampling design","text":"\nFigure 4.3: IDW mean distance data points fromleft right: 19.4, 20.2 40 m. Test site: Tydal\n\nFigure 4.4: IDW mean distance data points fromleft right: 9.1, 11.0, 17.3 44.5 m. Test site: Geilo\n","code":"\nIDW_tydal_i30 <- readRDS(\"Output/Tydal/IDW_tydal_i30.rds\")\nIDW_tydal_i60 <- readRDS(\"Output/Tydal/IDW_tydal_i60.rds\")\nIDW_tydal_i90 <- readRDS(\"Output/Tydal/IDW_tydal_i90.rds\")\ntmap_arrange(\ntm_shape(IDW_tydal_i30)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Interpolated peat\\ndepth (m)\"),\ntm_shape(IDW_tydal_i60)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Interpolated peat\\ndepth (m)\"),\ntm_shape(IDW_tydal_i90)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Interpolated peat\\ndepth (m)\")\n)\nIDW_geilo_i90 <- readRDS(\"Output/Geilo/IDW_geilo_i90.rds\")\nIDW_geilo_i140 <- readRDS(\"Output/Geilo/IDW_geilo_i140.rds\")\nIDW_geilo_i190 <- readRDS(\"Output/Geilo/IDW_geilo_i190.rds\")\nIDW_geilo_i240 <- readRDS(\"Output/Geilo/IDW_geilo_i240.rds\")\ntmap_arrange(\ntm_shape(IDW_geilo_i90)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Interpolated peat\\ndepth (m)\"),\ntm_shape(IDW_geilo_i140)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Interpolated peat\\ndepth (m)\"),\ntm_shape(IDW_geilo_i190)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Interpolated peat\\ndepth (m)\"),\ntm_shape(IDW_geilo_i240)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Interpolated peat\\ndepth (m)\")\n)"},{"path":"optimise-sampling-intensity.html","id":"distance-to-neighbours","chapter":"4 Optimise sampling intensity","heading":"4.4.2 Distance to neighbours","text":"Combine datasets\nFigure 4.5: Mean (grey) median (black) distance peat depth measurements along gradient sampling intensity.\nfigure tells us median (black) mean (grey) distance nearest neighbor similar, meaning little skew, meaning n reduction process retained systematic sampling design.","code":"\nsummaryTable_tydal$site <- \"Tydal\"\nsummaryTable_geilo$site <- \"Geilo\"\nsummaryTable_twoSites <- rbind(summaryTable_tydal,\n                               summaryTable_geilo)\nggplot(data = summaryTable_twoSites)+\n     geom_point(aes(x = n, y = medianDist))+\n     geom_point(aes(x = n, y = meanDist), pch = 21,fill=\"grey\")+\n     theme_bw(base_size = 16)+\n     ylab(\"Distance to nearest neighbour (m)\")+\n     ylim(0,60)+\n  facet_wrap(vars(site),\n             scales = \"free_x\")"},{"path":"optimise-sampling-intensity.html","id":"skewness","chapter":"4 Optimise sampling intensity","heading":"4.4.3 Skewness","text":"\nFigure 4.6: Skewness distribution euclidian distances response varying sapling intensity.\nContrary , figure indicates perhaps sampling designs compromised reduce n. starts negative skew due points close together. ‘weeded ’ first, skew flipped around become positive. mostly rely figure @ref(fig:sampling_reduction) @ref(fig:sampling_reduction_geilo) say reduction sampling intensity retains systamatic design.","code":"\n ggplot(data = summaryTable_twoSites)+\n     geom_point(aes(x = n, \n                    y = skewness), \n                pch = 21,fill=\"grey\")+\n     theme_bw(base_size = 16)+\n     ylab(\"Skewness\")+\n     facet_wrap(vars(site),\n                scales=\"free_x\")"},{"path":"optimise-sampling-intensity.html","id":"peat-volume-estimates","chapter":"4 Optimise sampling intensity","heading":"4.4.4 Peat volume estimates","text":"\nFigure 4.7: Estimated peat volume response median distance sampling points.\nTydal, estimated peat volume quite stable around 25 meter sampling points. Geilo, estimated volume increases zero 10-12 meters, stabilizing finally increasing distances 29 meters. correct prediction comes median distance 12-20 meters. original sampling density biased towards edges, resulting disproportionate large number samples shallow areas (Fig. @ref(fig:sampling_reduction_geilo) ). IDW seem able adequately control , care taken ensure balanced systematic sampling design.","code":"\n\ngg_volume <-    ggplot(data = summaryTable_twoSites,\n          aes(x = medianDist, \n              y = estimatedPeatVolume_m3))+\n     geom_point(\n                pch=21, \n                fill=\"grey\",\n                size=2)+\n     theme_bw(base_size = 16)+\n     ylab(expression(\"Est. peat volume (m\"^3*\")\"))+\n     xlab(\"Median distance to nearest neighbour (m)\")+\n     coord_trans(x=\"log2\")+\n     facet_wrap(vars(site),\n                scales=\"free\")\n\n\nggsave(\"Output/plot_distanceAgainstVolume.tiff\", gg_volume,\n       width = 1600, height = 1200, units = \"px\")\n\ngg_volume"},{"path":"optimise-sampling-intensity.html","id":"cv","chapter":"4 Optimise sampling intensity","heading":"4.4.5 CV","text":"addition seeing peat volume estimates becoming biased increasing distance sampling points, also variation increasing. Now calculate terms coefficient variation.’s quite data points higher categories. Perhaps .CV functionJoin tables\nFigure 4.8: Coefficient variation peat volume estimates response median distance sampling points\n","code":"\nmax(summaryTable_tydal$medianDist)\n#> [1] 54.87518\nmax(summaryTable_geilo$medianDist)\n#> [1] 44.49275\ntydal_cv <- summaryTable_tydal\ntydal_cv$group <- ifelse(\n  tydal_cv$medianDist<10, \"<10 m\", ifelse(\n    tydal_cv$medianDist<15, \"10-15 m\", ifelse(\n     tydal_cv$medianDist<20, \"15-20 m\", ifelse(\n       tydal_cv$medianDist<25, \"20-25 m\", ifelse(\n         tydal_cv$medianDist<30, \"25-30 m\", ifelse(\n           tydal_cv$medianDist<35, \"30-35 m\", ifelse(\n             tydal_cv$medianDist<40, \"35-40 m\", \"40-55 m\")))))))\ntydal_cv <- tydal_cv[tydal_cv$medianDist<100,]\n(tydal_n <- table(tydal_cv$group))\n#> \n#> 15-20 m 20-25 m 25-30 m 30-35 m 35-40 m 40-55 m \n#>      60      13      10       3       3       6\ngeilo_cv <- summaryTable_geilo\ngeilo_cv$group <- ifelse(\n  geilo_cv$medianDist<10, \"<10 m\", ifelse(\n    geilo_cv$medianDist<15, \"10-15 m\", ifelse(\n     geilo_cv$medianDist<20, \"15-20 m\", ifelse(\n       geilo_cv$medianDist<25, \"20-25 m\", ifelse(\n         geilo_cv$medianDist<30, \"25-30 m\", ifelse(\n           geilo_cv$medianDist<35, \"30-35 m\", ifelse(\n             geilo_cv$medianDist<40, \"35-40 m\", \"40-55 m\")))))))\ngeilo_cv <- geilo_cv[geilo_cv$medianDist<100,]\n(geilo_n <- table(geilo_cv$group))\n#> \n#>   <10 m 10-15 m 15-20 m 20-25 m 25-30 m 30-35 m 35-40 m \n#>     120      56      29      13      15       2       3 \n#> 40-55 m \n#>       4\ncv <- function(x){sd(x)/mean(x)}\ntydal_cv_tbl <- tapply(tydal_cv$estimatedPeatVolume_m3, tydal_cv$group, cv)\ntydal_cv_tbl <- data.frame(cv = tydal_cv_tbl,\n                      label = names(tydal_cv_tbl),\n                      order = c(3,4,5,6, 7,8))\ntydal_cv_tbl <- tydal_cv_tbl[order(tydal_cv_tbl$order),]\ntydal_cv_tbl$n <- tydal_n\n\ngeilo_cv_tbl <- tapply(geilo_cv$estimatedPeatVolume_m3, geilo_cv$group, cv)\ngeilo_cv_tbl <- data.frame(cv = geilo_cv_tbl,\n                      label = names(geilo_cv_tbl),\n                      order = c(1,2,3,4,5,6, 7,8))\ngeilo_cv_tbl <- geilo_cv_tbl[order(geilo_cv_tbl$order),]\ngeilo_cv_tbl$n <- geilo_n\ntydal_cv_tbl$site = \"Tydal\"\ngeilo_cv_tbl$site = \"Geilo\"\ncvTab <- rbind(tydal_cv_tbl,\n               geilo_cv_tbl)\ngg_cv <- ggplot(data = cvTab, \n                 aes(x = order, y = cv,\n                     fill=site,\n                     shape=site\n                     ))+\n  geom_line(lty = 2)+\n  scale_shape_manual(values=c(21,24))+\n  geom_point(\n             size=3, \n             stroke=1.5,\n             position = position_dodge(width=0.2))+\n  theme_bw(base_size = 16)+\n  scale_x_continuous(breaks = cvTab$order,\n                     labels = cvTab$label)+\n  theme(axis.text.x = element_text(angle = 90))+\n  xlab(\"\")\n\nggsave(\"Output/plot_distanceAgainstCV.tiff\", gg_cv,\n       width = 1600, height = 1200, units = \"px\")\n\ngg_cv"},{"path":"optimise-sampling-intensity.html","id":"mae","chapter":"4 Optimise sampling intensity","heading":"4.5 MAE","text":"\nFigure 4.9: MAE IDW predictions response median distance sampling points.\nfigure think also support sampling distances aboev 25 m bad idea.","code":"\ngg_mae <-    ggplot(data = summaryTable_twoSites,\n          aes(x = medianDist, \n              y = MAE))+\n     geom_point(\n                pch=21, \n                fill=\"grey\",\n                size=2)+\n     theme_bw(base_size = 16)+\n     ylab(\"Mean absolute error (m)\")+\n     xlab(\"Median distance to nearest neighbour (m)\")+\n     coord_trans(x=\"log2\")+\n     facet_wrap(vars(site),\n                scales=\"free\")\n\n\nggsave(\"Output/plot_distanceAgainstMAE.tiff\", gg_mae,\n       width = 1600, height = 1200, units = \"px\")\n\ngg_mae"},{"path":"validate-using-reduced-sampling-data.html","id":"validate-using-reduced-sampling-data","chapter":"5 Validate using reduced sampling data","heading":"5 Validate using reduced sampling data","text":"chapter 2 found optimal power settings Tydal Geilo sites. Now just want look might changed removed superflous data points chapter 3.Lets say Tydal want 20 meters sampling points.\nFigure 5.1: Peat depth measurements Tydal test site, trimming data poins median distance 20 meters.\nConfirm median distance 20 metersThen determine optimal power setting.’s good. optimum power data points.","code":"\ntm_shape(SHP_tydal)+\n  tm_polygons()+\ntm_shape(depths_tydal_i60)+\n  tm_dots(size=\"Dybde\",\n          scale=2,\n          col = \"Dybde\",\n          palette = \"-viridis\",\n          title = \"Measured peat depth (m)\")+\n  tm_layout(legend.outside = T)\ntemp <- sf::st_distance(depths_tydal_i60) \ntemp <- units::drop_units(temp)\ntemp[temp == 0] <- NA\ntemp <- rowMins(temp, na.rm=T)\nmedian(temp)\n#> [1] 20.18216\nccalc_optimumPower <- function(powerRange = 1:6,\n                               nmax = 20,\n                               peatDepths,\n                               peatlandDelimination,\n                               title\n                               ){\n  \n  temp <- data.frame(power = powerRange,\n                     MAE = as.numeric(NA))\n  \n  vol <- NULL\n  \n  myGrid <- starsExtra::make_grid(peatlandDelimination, 1)\n  myGrid <- sf::st_crop(myGrid, peatlandDelimination)\n  \n  for(i in powerRange){\n    \n    # Get the MAE\n    temp2 <- krige.cv(Dybde ~ 1, peatDepths, set = list(idp=i), nmax = nmax)\n    temp$MAE[temp$power==i] <- mean(abs(temp2$residual))\n    \n    #  Get the volume\n    vol_temp <- gstat::idw(Dybde ~ 1, peatDepths, \n                    newdata=myGrid, \n                    nmax=nmax, \n                    idp=i)\n    \n    vol <- c(vol, sum(vol_temp$var1.pred, na.rm=T))\n}\n  \n  \n  ifelse(temp$power[which.min(temp$MAE)]<2,\n  temp$best <- ifelse(temp$power==2, \"best\", \"not-best\"),\n  temp$best <- ifelse(temp$MAE==min(temp$MAE), \"best\", \"not-best\")\n  )\n\n  # Plot MAE\n  gg_out <- ggplot(temp, aes(x = power, y = MAE,\n                      colour = best,\n                      shape = best))+\n  geom_point(size=10)+\n  theme_bw(base_size = 12)+\n  scale_x_continuous(breaks = powerRange)+\n  guides(colour=\"none\",\n         shape = \"none\")+\n  scale_color_manual(values = c(\"darkgreen\",\"grey\"))+\n  scale_shape_manual(values = c(18, 19))+\n  ggtitle(title)\n  \n  # Plot volume\n  vol_df <- data.frame(\"volume\" = vol,\n                              \"power\" = powerRange)\n  vol_df$relative_volume <- vol_df$volume/mean(vol_df$volume)*100\n\n  \n  gg_out_vol <- \n    ggplot(vol_df, aes(x = factor(power), y = relative_volume))+\n       geom_point(size=8)+\n       xlab(\"power\")+\n       ylab(\"Peat volume as a percentage of\\nmean predicted peat volume\")+\n       theme_bw(base_size = 12)\n  \n  ggpubr::ggarrange(gg_out,\n                    gg_out_vol)\n}\nccalc_optimumPower(peatDepths = depths_tydal_i60,\n                   title = \"Tydal\",\n                   peatlandDelimination = SHP_tydal)\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]"},{"path":"carbon-stocks.html","id":"carbon-stocks","chapter":"6 Carbon stocks","heading":"6 Carbon stocks","text":"Now want convert peat volumes estimates carbon stock. conversion depends values peat characteristics, bulk density C concentrations. data set values.12 samples bogs, 14 fens.perhaps enough data points really compare different spesific peatland types.Lets get total peat volumes Tydal (Geilo, look Geilo ).Calculating c stocks (tons C) Tydal site without specifying mire typeI think also need estimate uncertainties around number. Note peat volume estimation, calculate uncertainty. peat characteristics uncertainty therms variation within samples points. calculate uncertainty points .\nFigure 6.1: Estaimted carbon stock Tydal peatland\ndistribution quite wide. Let’s summarize distribution.can put stuff generic function.Calculating summary statistics carbon stocks Tydal, using general peatland types.using bog data.finally, aslo fen data.\nFigure 6.2: Mean (+- 95 CI) carbon stock Tydal test site.\nSpecifying peatland type makes difference!Let’s just get (non-informed) C stock estimates Geilo well","code":"\npeatCharacteristics <- read_delim(\"Data/peatCharacteristics.csv\", \n    delim = \";\", escape_double = FALSE, locale = locale(encoding = \"ISO-8859-1\"), \n    trim_ws = TRUE)\n#> Rows: 88 Columns: 30\n#> -- Column specification ------------------------------------\n#> Delimiter: \";\"\n#> chr (17): SAMPLE ID2, Location Name, Municipality, Count...\n#> dbl (12): Sample No, ETRS89_UTM32_E, ETRS89_UTM32_N, BD ...\n#> lgl  (1): Condition_notes\n#> \n#> i Use `spec()` to retrieve the full column specification for this data.\n#> i Specify the column types or set `show_col_types = FALSE` to quiet this message.\nhead(peatCharacteristics)\n#> # A tibble: 6 x 30\n#>   `SAMPLE ID2` `Sample No` `Location Name`      Municipality\n#>   <chr>              <dbl> <chr>                <chr>       \n#> 1 0029                   1 Myr NV for Vesterse~ Namsos      \n#> 2 0029                   2 Myr NV for Vesterse~ Namsos      \n#> 3 0030                   1 Bakkemyr SV for Ves~ Namsos      \n#> 4 0031                   1 Skognbakkmyra        Namsos      \n#> 5 0031                   2 Skognbakkmyra        Namsos      \n#> 6 0031                   3 Skognbakkmyra        Namsos      \n#> # ... with 26 more variables: County <chr>,\n#> #   `General Peatland Type` <chr>,\n#> #   `Specific Peatland Type` <chr>,\n#> #   `Generell myrtype` <chr>, Naturtype <chr>,\n#> #   `Detaljert Naturtype` <chr>, `NiN kode` <chr>,\n#> #   Condition <chr>, Condition_notes <lgl>,\n#> #   Notes_misc <chr>, ETRS89_UTM32_E <dbl>, ...\n# Each sample consists of multiple sub samples from different depths. Here we will ignore the depth aspect, and simply take te mean from each sample core.\npeatCharacteristics_summedDepths <- peatCharacteristics %>% \n      mutate(perc_SOM = as.numeric(`% SOM`)) %>% \n      mutate(BD = as.numeric(`BD (t/m3)`)) %>% \n      dplyr::select(`SAMPLE ID2`, perc_SOM, BD) %>% \n      group_by(`SAMPLE ID2`) %>% \n      summarise(across(.fns = list(mean =~ mean(., na.rm=TRUE))))\n\n# Getting the other variables that I also want to keep\ndf_info <- peatCharacteristics %>% \n      dplyr::select(`SAMPLE ID2`, `General Peatland Type`, `Specific Peatland Type`) %>% \n      group_by(`SAMPLE ID2`) %>% \n      unique()\n# and join together again (this two-stap proceedure could be simplified)\ndf = full_join(peatCharacteristics_summedDepths, df_info, by = \"SAMPLE ID2\") %>% drop_na()\nhead(df)\n#> # A tibble: 6 x 5\n#>   `SAMPLE ID2` perc_SOM_mean BD_mean `General Peatland Type`\n#>   <chr>                <dbl>   <dbl> <chr>                  \n#> 1 0029                  98.3  0.05   fen                    \n#> 2 0030                  99.5  0.102  fen                    \n#> 3 0031                  98.2  0.0527 bog                    \n#> 4 0032                  95.9  0.0555 fen                    \n#> 5 0033                  96.6  0.067  fen                    \n#> 6 0034                  99.3  0.066  fen                    \n#> # ... with 1 more variable: `Specific Peatland Type` <chr>\ntable(df$`General Peatland Type`)\n#> \n#> bog fen \n#>  12  14\ntable(df$`Specific Peatland Type`)\n#> \n#>              bog intermediate fen      oceanic bog \n#>                3                5                2 \n#>         poor fen       raised bog         rich fen \n#>                5                7                4\nvolume\n#>    site    volume\n#> 1 Tydal  77336.97\n#> 2 Geilo 102268.39\nc_stock_tydal_uninformed <- \n              volume$volume[volume$site==\"Tydal\"] * \n              mean(df$perc_SOM_mean / 100) * \n              mean(df$BD_mean) * 0.5 #* 1000 # removing the original conversion from tons to kg\nc_stock_tydal_uninformed\n#> [1] 3519.665\nc_stock_tydal_uninformed <- NULL\nfor(i in 1:1000){\n temp <-      volume$volume[volume$site==\"Tydal\"] * \n              mean(sample(df$perc_SOM_mean, replace = T) / 100) * \n              mean(sample(df$BD_mean, replace = T) * 0.5)\n \n c_stock_tydal_uninformed <- c(c_stock_tydal_uninformed, temp)\n  }\nhist(c_stock_tydal_uninformed, main=\"\",\n     xlab=\"C stock\")\nc(quantile(c_stock_tydal_uninformed, c(.05, .5, .95)),\n  mean = mean(c_stock_tydal_uninformed), sd = sd(c_stock_tydal_uninformed))\n#>        5%       50%       95%      mean        sd \n#> 2998.6965 3496.7183 4042.6686 3511.7408  308.4893\nccalc_cStocks <- function(volume,\n                          peatlandType = c(\"fen\", \"bog\"),\n                          peatData){\n  temp_stocks <- NULL\n  temp_peatData <-  peatData[peatData$`General Peatland Type` %in% peatlandType,]\n    \n  for(i in 1:1000){\n    temp <-   volume * \n              mean(sample(peatData$perc_SOM_mean, replace = T) / 100) * \n              mean(sample(peatData$BD_mean, replace = T) * 0.5)\n \n    temp_stocks <- c(temp_stocks, temp)\n  }\n  return(c(quantile(temp_stocks, c(.05, .5, .95)),\n  mean = mean(temp_stocks), sd = sd(temp_stocks)))\n}\n(cstocks_tydal_unspecified <- \n  ccalc_cStocks(volume = volume$volume[volume$site==\"Tydal\"],\n              peatData = df))\n#>        5%       50%       95%      mean        sd \n#> 3028.5506 3504.3595 4016.4993 3511.9293  305.2949\n(cstocks_tydal_bog <- \n  ccalc_cStocks(volume = volume$volume[volume$site==\"Tydal\"],\n              peatData = df,\n              peatlandType = \"bog\"))\n#>        5%       50%       95%      mean        sd \n#> 3046.2127 3534.3871 4034.4952 3526.9671  303.6141\n(cstocks_tydal_fen <- \n  ccalc_cStocks(volume = volume$volume[volume$site==\"Tydal\"],\n              peatData = df,\n              peatlandType = \"fen\"))\n#>        5%       50%       95%      mean        sd \n#> 3023.6334 3504.1587 4023.3711 3512.9791  301.8405\ncstocks_tydal_unspecified_df <- as.data.frame(cstocks_tydal_unspecified)\nnames(cstocks_tydal_unspecified_df) <- \"C stocks\"\ncstocks_tydal_unspecified_df$summary <- row.names(cstocks_tydal_unspecified_df)\ncstocks_tydal_unspecified_df$information <- \"Unspesified\"\n\n\ncstocks_tydal_bog_df <- as.data.frame(cstocks_tydal_bog)\nnames(cstocks_tydal_bog_df) <- \"C stocks\"\ncstocks_tydal_bog_df$summary <- row.names(cstocks_tydal_bog_df)\ncstocks_tydal_bog_df$information <- \"Bog\"\n\ncstocks_tydal_fen_df <- as.data.frame(cstocks_tydal_fen)\nnames(cstocks_tydal_fen_df) <- \"C stocks\"\ncstocks_tydal_fen_df$summary <- row.names(cstocks_tydal_fen_df)\ncstocks_tydal_fen_df$information <- \"Fen\"\n\ncstocks_tydal_compare <- rbind(\n  cstocks_tydal_fen_df,\n  cstocks_tydal_bog_df,\n  cstocks_tydal_unspecified_df\n)\n\n# Pivot\ncstocks_tydal_compare <- pivot_wider(cstocks_tydal_compare,\n                                      names_from = summary,\n                                      values_from = \"C stocks\"\n                                      )\nggplot(cstocks_tydal_compare,\n       aes(x = information))+\n  geom_point(aes(y = mean), shape=15, size=10) +\n  geom_linerange(aes(ymin=`5%`, \n                     ymax=`95%`),\n                 size=2)+ \n  theme_bw(base_size = 16)+\n  labs(x = \"Peat characteristics\",\n       y = \"Carbon stocks (tons)\")\nccalc_cStocks(volume = 102444.14,\n              peatData = df)\n#>       5%      50%      95%     mean       sd \n#> 3936.979 4616.614 5349.353 4627.271  424.368"},{"path":"additional-test-sites.html","id":"additional-test-sites","chapter":"7 Additional test sites","heading":"7 Additional test sites","text":"used two contrastong sites, Tydal Geilo, main analyses testing. Now bring additinal three sites validate gernerality finding.","code":""},{"path":"additional-test-sites.html","id":"modalen","chapter":"7 Additional test sites","heading":"7.1 Modalen","text":"Import shape files peatland delineations.Another shape filw project area (see )Import depth samples\nFigure 7.1: Modalen test site sith peatland delineated grey polygons. Crosses peat depth samples, contained project area (dotted line).\ndepth measurements done within bigger project area, also covering non-peat areas. depth measurements come ground boring, rather simple peat probe, may reflect depth including mineral layers bottom. therefore use points IDW think. example illustrates importance appropriate sampling. now limited just data points. smaller mires one two datapoints.Calculating combined area five mires.area project delineationRemoving depth measurement outside peatland delinitaion\nFigure 7.2: Modalen test site sith peatland delineated grey polygons. Crosses peat depth samples, contained project area (dotted line). depth measurements intersects mire polygons included\nCreate raster grid\nFigure 7.3: Checking raster grid Modalen looks correct.\nPredict peat depthUnsurprising, data points, optimum power low. predict using power 1 though 3 compare, just don’t trus power 1 best choice.\nFigure 7.4: IDW peat depth Modalen test site.\nthink power 3 looks accurate way gives weight local points. recommended practice case think analyse polyong mire separately point neighboring mires affect depth predictions.Summary stats peat depth Modalen.MAE power =3 prediction 0.82 m.rough volume (m3), mean peat depth multiplied area, isNumber depth samples per 100 m2:Interpolated volumeEstimated carbon stocks Modalen site:","code":"\nSHP_modalen <- sf::read_sf(\"Data/Modalen/Modalen_myrareal.shp\")\n#st_crs(SHP_modalen) #OK\nSHP_modalen_project <- sf::read_sf(\"Data/Modalen/modalen_shp.shp\") \n#st_crs(SHP_modalen_project) # OK\ndepths_modalen <- sf::read_sf(\"Data/Modalen/modalen_punkter.shp\")\n#st_crs(depths_modalen) #OK\ntm_shape(SHP_modalen)+\n  tm_polygons()+\n  tm_shape(depths_modalen)+\n  tm_symbols(col=\"black\",\n             size=.5,\n             shape=4)+\n  tm_shape(SHP_modalen_project)+\n  tm_borders(lty=\"dotted\")+\n  tm_compass(type=\"8star\", position = c(\"right\", \"bottom\"), size = 2) +\n  tm_scale_bar(position = c(\"left\", \"bottom\"), width = 0.3)+\n  tm_layout(inner.margins = c(0.15, 0.05, 0.05, 0.05))\nSHP_modalen$myArea <- sf::st_area(SHP_modalen)\nsum(SHP_modalen$myArea)\n#> 16752.75 [m^2]\nSHP_modalen_project$myArea <- sf::st_area(SHP_modalen_project)\nSHP_modalen_project$myArea\n#> 36179.43 [m^2]\ndepths_modalen_reduced <- sf::st_intersection(depths_modalen, SHP_modalen)\n#> Warning: attribute variables are assumed to be spatially\n#> constant throughout all geometries\ntm_shape(SHP_modalen)+\n  tm_polygons()+\n  tm_shape(depths_modalen_reduced)+\n  tm_symbols(col=\"black\",\n             size=.5,\n             shape=4)+\n  tm_shape(SHP_modalen_project)+\n  tm_borders(lty=\"dotted\")+\n  tm_compass(type=\"8star\", position = c(\"right\", \"bottom\"), size = 2) +\n  tm_scale_bar(position = c(\"left\", \"bottom\"), width = 0.3)+\n  tm_layout(inner.margins = c(0.15, 0.05, 0.05, 0.05))\n#First fix polygon closure\nSHP_modalen <- sf::st_make_valid(SHP_modalen)\n\n\ngrid_Modalen_stars_crop <- starsExtra::make_grid(SHP_modalen, 1) %>%\n  sf::st_crop(SHP_modalen)\ntm_shape(grid_Modalen_stars_crop)+\n  tm_raster()\nccalc_optimumPower(nmax=nrow(depths_modalen_reduced),\n                   peatDepths = depths_modalen_reduced,\n                   title=\"Modalen\",\n                   peatlandDelimination = SHP_modalen)\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\nIDW_Modalen_1 <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_modalen_reduced, \n           newdata = grid_Modalen_stars_crop, \n           idp=1,\n           nmax = 20) # nmax > than the number of points\n#> [inverse distance weighted interpolation]\n\nIDW_Modalen_2 <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_modalen_reduced, \n           newdata = grid_Modalen_stars_crop, \n           idp=2,\n           nmax = nrow(depths_modalen_reduced))\n#> [inverse distance weighted interpolation]\n\nIDW_Modalen_3 <- gstat::idw(formula = Dybde ~ 1, \n           locations = depths_modalen_reduced, \n           newdata = grid_Modalen_stars_crop, \n           idp=3,\n           nmax = nrow(depths_modalen_reduced))\n#> [inverse distance weighted interpolation]\ntmap_arrange(\ntm_shape(IDW_Modalen_1)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Power = 1\\nInterpolated peat\\ndepth (m)\",\n            breaks = seq(0,3,.5))+\n  tm_compass(type=\"8star\", position = c(\"right\", \"bottom\"), size = 2) +\n  tm_scale_bar(position = c(\"right\", \"bottom\"), width = 0.3)+\n  tm_shape(depths_modalen_reduced)+\n  tm_symbols(shape=4,\n             col=\"black\",\n             size=.5)+\n  tm_layout(legend.outside = T)\n,\ntm_shape(IDW_Modalen_2)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Power = 2\\nInterpolated peat\\ndepth (m)\",\n            breaks = seq(0,3,.5))+\n  tm_compass(type=\"8star\", position = c(\"right\", \"bottom\"), size = 2) +\n  tm_scale_bar(position = c(\"right\", \"bottom\"), width = 0.3)+\n  tm_shape(depths_modalen_reduced)+\n  tm_symbols(shape=4,\n             col=\"black\",\n             size=.5)+\n  tm_layout(legend.outside = T)\n,\ntm_shape(IDW_Modalen_3)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Power = 3\\nInterpolated peat\\ndepth (m)\",\n            breaks = seq(0,3,.5))+\n  tm_compass(type=\"8star\", position = c(\"right\", \"bottom\"), size = 2) +\n  tm_scale_bar(position = c(\"right\", \"bottom\"), width = 0.3)+\n  tm_shape(depths_modalen_reduced)+\n  tm_symbols(shape=4,\n             col=\"black\",\n             size=.5)+\n  tm_layout(legend.outside = T)\n\n)\n#> Legend labels were too wide. The labels have been resized to 0.46, 0.46, 0.46, 0.46, 0.46, 0.46. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\n#> Legend labels were too wide. The labels have been resized to 0.46, 0.46, 0.46, 0.46, 0.46, 0.46. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\n#> Legend labels were too wide. The labels have been resized to 0.46, 0.46, 0.46, 0.46, 0.46, 0.46. Increase legend.width (argument of tm_layout) to make the legend wider and therefore the labels larger.\nsummary(depths_modalen_reduced$Dybde)\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#>   0.000   0.400   0.600   1.017   1.475   2.800\nmean(depths_modalen_reduced$Dybde)*sum(SHP_modalen$myArea)\n#> 17031.97 [m^2]\n12/(sum(SHP_modalen$myArea)/100)\n#> 0.07163001 [1/m^2]\n(volume_modalen <- sum(IDW_Modalen_3$var1.pred, na.rm=T))\n#> [1] 16792.6\nccalc_cStocks(volume_modalen, peatData = df)\n#>        5%       50%       95%      mean        sd \n#> 653.22600 761.29902 875.01234 765.12104  67.81018"},{"path":"additional-test-sites.html","id":"opelandsmarka","chapter":"7 Additional test sites","heading":"7.2 Opelandsmarka","text":"Import shape fileThe depth measurements three different files.\nFigure 7.5: Test site: Opelandsmarka. Crosses peat depth measurements.\nthink can ignore top mire sampled nearly intensive two.good idea sometimes include depth measurements outside mire polygons (depth 0). easier just exclude points outide polygon.\nFigure 7.6: Opelandsmarka two three mires. Crosses peat depth measurements.\none NA depth data removeTry :\nFigure 7.7: Determening optimal power Opelandsmarka test site.\nlowest MAE obtained power 1, seen, power probably set higher. predicted peat volume example quite unstable low power settings.Create raster grid predictionsThe depths recorded cm meters. Converting m.power set 1 model flat, deep areas identified correctly. Power 2 3 makes less difference. Becaus ethe MAE volume estimates similar, chose modet local model (power = 3)Getting total peatland areaGetting mean peat depth (excluding points outside polygons)Rough volumeNumber peat depth measurementsDepth measurement density (points per 100 m-2)Interpolated peat volume (best model)Estimated C stocks","code":"\nSHP_opelandsmarka <- sf::read_sf(\"Data/Opelandsmarka/Opelandsmarka Voss.shp\")\n#st_crs(SHP_opedalsmarka) #32632 UTM 32\ndepths_opelandsmarka1 <- read_delim(\"Data/Opelandsmarka/Torvdybder_Opelandsmarka_myr1.csv\", \n    delim = \";\", escape_double = FALSE, locale = locale(encoding = \"ISO-8859-1\"), \n    trim_ws = TRUE)\ndepths_opelandsmarka2 <- read_delim(\"Data/Opelandsmarka/Torvdybder_Opelandsmarka_myr2.csv\", \n    delim = \";\", escape_double = FALSE, locale = locale(encoding = \"ISO-8859-1\"), \n    trim_ws = TRUE)\ndepths_opelandsmarka3 <- read_delim(\"Data/Opelandsmarka/Torvdybder_Opelandsmarka_myr3.csv\", \n    delim = \";\", escape_double = FALSE, locale = locale(encoding = \"ISO-8859-1\"), \n    trim_ws = TRUE)\n# The last one is missing a column\n\ndepths_opelandsmarka <- bind_rows(depths_opelandsmarka1,\n                                  depths_opelandsmarka2,\n                                  depths_opelandsmarka3)\n\n\ndepths_opelandsmarka <- sf::st_as_sf(depths_opelandsmarka,\n                                     coords = c(\"UTM_N_ZONE32N\", \"UTM_E_ZONE32N\"),\n                                     crs = 32632)\ntm_shape(SHP_opelandsmarka)+\n  tm_polygons()+\n  tm_shape(depths_opelandsmarka)+\n  tm_symbols(col=\"black\",\n             size=.5,\n             shape=4)\nSHP_opelandsmarka_twoMires <- SHP_opelandsmarka[-1,]\ndepths_opelandsmarka <- st_intersection(depths_opelandsmarka, SHP_opelandsmarka_twoMires)\n#> Warning: attribute variables are assumed to be spatially\n#> constant throughout all geometries\ntm_shape(SHP_opelandsmarka_twoMires)+\n  tm_polygons()+\n  tm_shape(depths_opelandsmarka)+\n  tm_symbols(col=\"black\",\n             size=.5,\n             shape=4)\ndepths_opelandsmarka <- depths_opelandsmarka[!is.na(depths_opelandsmarka$Dybde),]\nccalc_optimumPower(peatDepths = depths_opelandsmarka, \n                   title = \"Opelandsmarka\",\n                   peatlandDelimination = SHP_opelandsmarka_twoMires)\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\ngrid_Opelandsmarka_stars_crop <- starsExtra::make_grid(SHP_opelandsmarka_twoMires, 1) %>%\n  sf::st_crop(SHP_opelandsmarka_twoMires)\ndepths_opelandsmarka$Dybde <- depths_opelandsmarka$Dybde/100\nIDW_opelandsmarka_1 <- gstat::idw(Dybde ~ 1, depths_opelandsmarka, \n                    newdata=grid_Opelandsmarka_stars_crop, \n                    nmax=nmax, \n                    idp=1)\n#> [inverse distance weighted interpolation]\n\nIDW_opelandsmarka_2 <- gstat::idw(Dybde ~ 1, depths_opelandsmarka, \n                    newdata=grid_Opelandsmarka_stars_crop, \n                    nmax=nmax, \n                    idp=2)\n#> [inverse distance weighted interpolation]\n\nIDW_opelandsmarka_3 <- gstat::idw(Dybde ~ 1, depths_opelandsmarka, \n                    newdata=grid_Opelandsmarka_stars_crop, \n                    nmax=nmax, \n                    idp=3)\n#> [inverse distance weighted interpolation]\nmyBreaks <- seq(0,3,.5)\nmyPos <- c(\"left\", \"bottom\")\n\ntmap_arrange(\ntm_shape(IDW_opelandsmarka_1)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Power = 1\\nInterpolated peat\\ndepth (m)\",\n            breaks = myBreaks)+\n  tm_compass(type=\"8star\", position = myPos, size = 2) +\n  tm_scale_bar(position = myPos, width = 0.3)+\n  tm_shape(depths_opelandsmarka)+\n  tm_symbols(shape=4,\n             col=\"black\",\n             size=.5)+\n  tm_layout(legend.outside = T)\n,\ntm_shape(IDW_opelandsmarka_2)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Power = 2\\nInterpolated peat\\ndepth (m)\",\n            breaks = myBreaks)+\n  tm_compass(type=\"8star\", position = myPos, size = 2) +\n  tm_scale_bar(position = myPos, width = 0.3)+\n  tm_shape(depths_opelandsmarka)+\n  tm_symbols(shape=4,\n             col=\"black\",\n             size=.5)+\n  tm_layout(legend.outside = T)\n,\ntm_shape(IDW_opelandsmarka_3)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Power = 3\\nInterpolated peat\\ndepth (m)\",\n            breaks = myBreaks)+\n  tm_compass(type=\"8star\", position = myPos, size = 2) +\n  tm_scale_bar(position = myPos, width = 0.3)+\n  tm_shape(depths_opelandsmarka)+\n  tm_symbols(shape=4,\n             col=\"black\",\n             size=.5)+\n  tm_layout(legend.outside = T),\nncol = 2\n\n)\nSHP_opelandsmarka_twoMires$myArea <- sf::st_area(SHP_opelandsmarka_twoMires)\nsum(SHP_opelandsmarka_twoMires$myArea)\n#> 8700.213 [m^2]\nmean(depths_opelandsmarka$Dybde)\n#> [1] 1.058333\nmean(depths_opelandsmarka$Dybde) * sum(SHP_opelandsmarka_twoMires$myArea)\n#> 9207.725 [m^2]\nnrow(depths_opelandsmarka)\n#> [1] 54\nnrow(depths_opelandsmarka)/(sum(SHP_opelandsmarka_twoMires$myArea)/100)\n#> 0.6206745 [1/m^2]\n(vol_temp <- sum(IDW_opelandsmarka_3$var1.pred, na.rm=T))\n#> [1] 9270.232\nccalc_cStocks(volume = vol_temp,\n              peatData = df)\n#>        5%       50%       95%      mean        sd \n#> 362.60768 423.61840 483.41071 422.93686  36.21115"},{"path":"additional-test-sites.html","id":"kinn-1","chapter":"7 Additional test sites","heading":"7.3 Kinn 1","text":"peat depth data doesn’t contain coordinated. Importing now.column name shared two datasets can use merge . First need remove leading zeros.still one NA removeCheck CRS\nFigure 7.8: Test site Kinn1.\nnice example data set. notice however, points near edges.Getting rough volumeMean depthThe depths cm. Converting m.Number depth measurementsPoint density (100 m-2)Finding optimum power\nFigure 7.9: Finding best power setting Kinn1 test site.\noptimal power 5.Create raster grid predictionsMax peat depth\nFigure 7.10: Best model test site Kinn1\nPredicted peat volumeCarbon stocks","code":"\n# import peatland delineation\nSHP_kinn1 <- sf::st_read(\"Data/Kinn/rikmyr_avgrensing.shp\")\n#> Reading layer `rikmyr_avgrensing' from data source \n#>   `C:\\Users\\anders.kolstad\\Documents\\Github\\carbonCalculator\\Data\\Kinn\\rikmyr_avgrensing.shp' \n#>   using driver `ESRI Shapefile'\n#> Simple feature collection with 1 feature and 27 fields\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 5.099473 ymin: 61.48336 xmax: 5.102058 ymax: 61.48463\n#> Geodetic CRS:  WGS 84\n\n# import peat deth data\ndepths_kinn1 <- read_delim(\"Data/Kinn/data_rikmyr_torvdybder.csv\", \n    delim = \";\", escape_double = FALSE, locale = locale(encoding = \"ISO-8859-1\"), \n    trim_ws = TRUE)\n#> Rows: 36 Columns: 4\n#> -- Column specification ------------------------------------\n#> Delimiter: \";\"\n#> chr (2): Lokalitet, Notat\n#> dbl (2): name, Dybde\n#> \n#> i Use `spec()` to retrieve the full column specification for this data.\n#> i Specify the column types or set `show_col_types = FALSE` to quiet this message.\ndepths_kinn1_spatial <- sf::st_read(\"Data/Kinn/rikmyr_punkter.shp\")\n#> Reading layer `rikmyr_punkter' from data source \n#>   `C:\\Users\\anders.kolstad\\Documents\\Github\\carbonCalculator\\Data\\Kinn\\rikmyr_punkter.shp' \n#>   using driver `ESRI Shapefile'\n#> Simple feature collection with 37 features and 24 fields\n#> Geometry type: POINT\n#> Dimension:     XYZ\n#> Bounding box:  xmin: 5.099712 ymin: 61.48347 xmax: 5.101931 ymax: 61.48458\n#> z_range:       zmin: 18.489 zmax: 44.38\n#> Geodetic CRS:  WGS 84\ndepths_kinn1_spatial$name <- as.numeric(depths_kinn1_spatial$name)\ndepths_kinn1_spatial$Dybde <- depths_kinn1$Dybde[match(depths_kinn1_spatial$name, depths_kinn1$name)]\nrm(depths_kinn1)\ndepths_kinn1_spatial <- depths_kinn1_spatial[!is.na(depths_kinn1_spatial$Dybde),]\n#st_crs(depths_kinn1_spatial) # lat long\n#st_crs(SHP_kinn1) # also lat long\n\ndepths_kinn1_spatial <- sf::st_transform(depths_kinn1_spatial, 25833)\nSHP_kinn1 <- sf::st_transform(SHP_kinn1, 25833)\ntm_shape(SHP_kinn1)+\n  tm_polygons()+\n  tm_shape(depths_kinn1_spatial)+\n  tm_symbols(col=\"black\",\n             size=.5,\n             shape=4)\nSHP_kinn1$myArea <- sf::st_area(SHP_kinn1)\nSHP_kinn1$myArea\n#> 13541.53 [m^2]\nmean(depths_kinn1_spatial$Dybde, na.rm=T)\n#> [1] 244.1429\ndepths_kinn1_spatial$Dybde <- depths_kinn1_spatial$Dybde/100\nnrow(depths_kinn1_spatial)\n#> [1] 35\nnrow(depths_kinn1_spatial) / (SHP_kinn1$myArea )*100\n#> 0.2584641 [1/m^2]\nccalc_optimumPower(peatDepths = depths_kinn1_spatial,\n                   peatlandDelimination = SHP_kinn1,\n                   title = \"Kinn1\")\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\ngrid_kinn1_stars_crop <- starsExtra::make_grid(SHP_kinn1, 1) %>%\n  sf::st_crop(SHP_kinn1)\nIDW_kinn1_5 <- gstat::idw(Dybde ~ 1, depths_kinn1_spatial, \n                    newdata=grid_kinn1_stars_crop, \n                    nmax=nmax, \n                    idp=5)\n#> [inverse distance weighted interpolation]\nmax(depths_kinn1_spatial$Dybde)\n#> [1] 4.7\nmyBreaks <- seq(0,5,1)\nmyPos <- c(\"right\", \"bottom\")\n\ntm_shape(IDW_kinn1_5)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Power = 5\\nInterpolated peat\\ndepth (m)\",\n            breaks = myBreaks)+\n  tm_compass(type=\"8star\", position = myPos, size = 2) +\n  tm_scale_bar(position = myPos, width = 0.3)+\n  tm_shape(depths_kinn1_spatial)+\n  tm_symbols(shape=4,\n             col=\"black\",\n             size=.5)+\n  tm_layout(legend.outside = T)\n(vol_temp <- sum(IDW_kinn1_5$var1.pred, na.rm=T))\n#> [1] 33530.09\nccalc_cStocks(volume = vol_temp,\n              peatData = df)\n#>       5%      50%      95%     mean       sd \n#> 1284.029 1528.301 1745.019 1527.317  137.476"},{"path":"additional-test-sites.html","id":"kinn2","chapter":"7 Additional test sites","heading":"7.4 Kinn2","text":", depths coordinates.Transform UTF33\nFigure 7.11: Test site Kinn2.\nmean depthConverting cm mAreaNumber peat depth measurementsDensity points (100 m-2)Find optimal power\nFigure 7.12: Finding best power setting Kinn1 test site.\nPower = 4 best.Create raster grid predictionsInterpreted peat volume\nFigure 7.13: Best model test site Kinn2\nvolume isAnd C stock","code":"\nSHP_kinn2 <- sf::st_read(\"Data/Kinn/maroy_avgrensing.shp\")\n#> Reading layer `maroy_avgrensing' from data source \n#>   `C:\\Users\\anders.kolstad\\Documents\\Github\\carbonCalculator\\Data\\Kinn\\maroy_avgrensing.shp' \n#>   using driver `ESRI Shapefile'\n#> Simple feature collection with 1 feature and 27 fields\n#> Geometry type: POLYGON\n#> Dimension:     XY\n#> Bounding box:  xmin: 5.102353 ymin: 61.50691 xmax: 5.107625 ymax: 61.50866\n#> Geodetic CRS:  WGS 84\ndepths_kinn2 <- read_delim(\"Data/Kinn/data_maroy_torvdybder.csv\", \n    delim = \";\", escape_double = FALSE, locale = locale(encoding = \"ISO-8859-1\"), \n    trim_ws = TRUE)\n#> Rows: 78 Columns: 4\n#> -- Column specification ------------------------------------\n#> Delimiter: \";\"\n#> chr (2): Lokalitet, Notat\n#> dbl (2): name, Dybde\n#> \n#> i Use `spec()` to retrieve the full column specification for this data.\n#> i Specify the column types or set `show_col_types = FALSE` to quiet this message.\ndepths_kinn2_spatial <- sf::st_read(\"Data/Kinn/maroy_punkter.shp\")\n#> Reading layer `maroy_punkter' from data source \n#>   `C:\\Users\\anders.kolstad\\Documents\\Github\\carbonCalculator\\Data\\Kinn\\maroy_punkter.shp' \n#>   using driver `ESRI Shapefile'\n#> Simple feature collection with 78 features and 24 fields\n#> Geometry type: POINT\n#> Dimension:     XYZ\n#> Bounding box:  xmin: 5.102523 ymin: 61.50698 xmax: 5.10742 ymax: 61.5086\n#> z_range:       zmin: 8.484 zmax: 17.732\n#> Geodetic CRS:  WGS 84\ndepths_kinn2_spatial$name <- as.numeric(depths_kinn2_spatial$name)\ndepths_kinn2_spatial$Dybde <- depths_kinn2$Dybde[match(depths_kinn2_spatial$name, depths_kinn2$name)]\nrm(depths_kinn2)\ndepths_kinn2_spatial <- sf::st_transform(depths_kinn2_spatial, 25833)\nSHP_kinn2 <- sf::st_transform(SHP_kinn2, 25833)\ntm_shape(SHP_kinn2)+\n  tm_polygons()+\n  tm_shape(depths_kinn2_spatial)+\n  tm_symbols(col=\"black\",\n             size=.5,\n             shape=4)\nsummary(depths_kinn2_spatial$Dybde, na.rm=T)\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#>    0.00   41.25   71.00   90.26  130.25  282.00\ndepths_kinn2_spatial$Dybde <- depths_kinn2_spatial$Dybde/100\nSHP_kinn2$myArea <- st_area(SHP_kinn2)\nnrow(depths_kinn2_spatial)\n#> [1] 78\nnrow(depths_kinn2_spatial)\n#> [1] 78\nnrow(depths_kinn2_spatial)/SHP_kinn2$myArea*100\n#> 0.2346467 [1/m^2]\nccalc_optimumPower(peatDepths = depths_kinn2_spatial,\n                   peatlandDelimination = SHP_kinn2,\n                   title = \"Kinn2\")\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\n#> [inverse distance weighted interpolation]\ngrid_kinn2_stars_crop <- starsExtra::make_grid(SHP_kinn2, 1) %>%\n  sf::st_crop(SHP_kinn2)\nIDW_kinn2_4 <- gstat::idw(Dybde ~ 1, depths_kinn2_spatial, \n                    newdata=grid_kinn2_stars_crop, \n                    nmax=nmax, \n                    idp=4)\n#> [inverse distance weighted interpolation]\nmyBreaks <- seq(0,3,.5)\nmyPos <- c(\"right\", \"bottom\")\n\ntm_shape(IDW_kinn2_4)+\n  tm_raster(col=\"var1.pred\",\n            palette = \"-viridis\",\n            title = \"Power = 4\\nInterpolated peat\\ndepth (m)\",\n            breaks = myBreaks)+\n  tm_compass(type=\"8star\", position = myPos, size = 2) +\n  tm_scale_bar(position = myPos, width = 0.3)+\n  tm_shape(depths_kinn2_spatial)+\n  tm_symbols(shape=4,\n             col=\"black\",\n             size=.5)+\n  tm_layout(legend.outside = T)\n(vol_temp <- sum(IDW_kinn2_4$var1.pred, na.rm=T))\n#> [1] 33037.11\nccalc_cStocks(volume = vol_temp,\n              peatData = df)\n#>        5%       50%       95%      mean        sd \n#> 1300.0486 1509.6668 1719.2347 1507.1071  128.2847"}]
