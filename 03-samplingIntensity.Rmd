# Optimise sampling intensity

Now I want to resample and reduce the dataset, but try to keep the original sampling design. 
For the Geilo dataset I want to limit this part of the analyses to only consider one polygon. It is obvious that a peat depth measurement from a neighboring mire cannot replace data collection on the actuall mire.

## Subset Geilo data

```{r, warning=FALSE}
# select a single mire polygon
SHP_geilo_biggest <- SHP_geilo[which.max(SHP_geilo$AREAL),]

# drop the depth measurements from the other polygons
depths_geilo_biggest <- sf::st_intersection(depths_geilo, SHP_geilo_biggest)

#Crop the raster grid
grid_Geilo_stars_crop_biggest <- sf::st_crop(grid_Geilo_stars, SHP_geilo_biggest)
```
```{r, fig.cap="Peat depth measurements for tge biggest of the Geilo mires."}
plot(depths_geilo_biggest$Dybde[order(depths_geilo_biggest$Dybde)],
     ylab="Peat depth (m)")
```

Looking at the depth measurements in the figure above, we are reminded that the data contains zeros (measurements taken near the edge) and a truncated above 3 (because that was the length of the peat depth probe).


```{r, fig.cap="One mire polygon from the Geilo test site used in the assessment of minimum sampling."}
tm_shape(SHP_geilo_biggest)+
  tm_polygons()+
  tm_shape(depths_geilo_biggest)+
  tm_symbols(col="black",
             shape=4)

```

## Repeat the best IDW
Here I simply recalculate the best models, as described in the previous chapter
```{r}
IDW_tydal_4 <- gstat::idw(formula = Dybde ~ 1, 
           locations = depths_tydal, 
           newdata = grid_Tydal_stars_crop, 
           idp=4,
           nmax = nmax)

IDW_geilo_2 <- gstat::idw(formula = Dybde ~ 1, 
           locations = depths_geilo_biggest, 
           newdata = grid_Geilo_stars_crop_biggest, 
           idp=2,
           nmax = nmax)
```


## Reduce N
by gradually removing the closest point.

First we need to set up some temporary files for the for-loop.

```{r}
distMatrix_tydal <- sf::st_distance(depths_tydal) 
distMatrix_tydal <- units::drop_units(distMatrix_tydal)
distMatrix_tydal[distMatrix_tydal == 0] <- NA
distMin_tydal <- matrixStats::rowMins(distMatrix_tydal, na.rm=T)

distMatrix_geilo <- sf::st_distance(depths_geilo_biggest) 
distMatrix_geilo <- units::drop_units(distMatrix_geilo)
distMatrix_geilo[distMatrix_geilo == 0] <- NA
distMin_geilo <- matrixStats::rowMins(distMatrix_geilo, na.rm=T)
```


Create temporary working files
```{r}
distMin_tydal_temp <- distMin_tydal
depths_tydal_temp <- depths_tydal

distMin_geilo_temp <- distMin_geilo
depths_geilo_temp <- depths_geilo_biggest
```


Get the summed volume
```{r}
est_tydal <- sum(IDW_tydal_4$var1.pred, na.rm=T)
est_geilo <- sum(IDW_geilo_2$var1.pred, na.rm=T)
```

Get the median, mean and skewness of the distances to the closest neighbor
```{r}
medianDist_tydal <- median(distMin_tydal)
meanDist_tydal <- mean(distMin_tydal)
skewDist_tydal <- e1071::skewness(distMin_tydal)

medianDist_geilo <- median(distMin_geilo)
meanDist_geilo <- mean(distMin_geilo)
skewDist_geilo <- e1071::skewness(distMin_geilo)
```

Get the MAE
```{r}
MAE_tydal_allData <- krige.cv(Dybde ~ 1, depths_tydal, set = list(idp=4), nmax = nmax)
MAE_tydal_allData <- mean(abs(MAE_tydal_allData$residual))

MAE_geilo_allData <- krige.cv(Dybde ~ 1, depths_geilo_biggest, set = list(idp=2), nmax = nmax)
MAE_geilo_allData <- mean(abs(MAE_geilo_allData$residual))
```


Put it into a dataframe
```{r}
summaryTable_tydal <- data.frame(
  medianDist             = medianDist_tydal,
  meanDist               = meanDist_tydal,
  skewness               = skewDist_tydal,
  n                      = length(distMin_tydal),
  estimatedPeatVolume_m3 = est_tydal,
  MAE                    = MAE_tydal_allData
)

summaryTable_geilo <- data.frame(
  medianDist             = medianDist_geilo,
  meanDist               = meanDist_geilo,
  skewness               = skewDist_geilo,
  n                      = length(distMin_geilo),
  estimatedPeatVolume_m3 = est_geilo,
  MAE                    = MAE_geilo_allData
)
```

Perform a for-loop to gradually remove points based on how close they are to other points. This will hopefully retain most of the systematic design of the points (avoiding clumping of points).

```{r, eval=F}
# I will not bother going lower than ten data points
for(i in 1:c(nrow(depths_tydal)-10)){
  
 print(paste("run number = ", i))
  
 toRemove <- which(distMin_tydal_temp == min(distMin_tydal_temp))[1]
 print(paste("Removing row number ", toRemove))
 
 # get some stats distance between neighbours
 medianDist <- median(distMin_tydal_temp)
 meanDist   <- mean(distMin_tydal_temp)
 skewDist   <- e1071::skewness(distMin_tydal_temp)

 depths_tydal_temp <- depths_tydal_temp[-toRemove,]

 # perform interpolation on tempDF
  int <- gstat::idw(Dybde ~ 1, depths_tydal_temp, 
                    newdata=grid_Tydal_stars_crop, 
                    nmax=nmax, idp=4)
  
  # Export some predictions for checks
  if(i %in% seq(30, 90, 30)){
    assign(paste0("IDW_tydal_i", i), int)
  }
  
  
  est <- sum(int$var1.pred, na.rm=T)
  
  # get the MAE as well, even though it takes a long time to run
  MAE <- krige.cv(Dybde ~ 1, depths_tydal_temp, set = list(idp=4), nmax = nmax)
  MAE <- mean(abs(MAE$residual))
  
 # paste into the summary table
 summaryTable_tydal[1+i,"medianDist"]      <- medianDist
 summaryTable_tydal[1+i,"meanDist"]        <- meanDist
 summaryTable_tydal[1+i,"skewness"]        <- skewDist
 summaryTable_tydal[1+i,"n"]               <- length(distMin_tydal_temp)-1
 summaryTable_tydal[1+i,"estimatedPeatVolume_m3"]           <- est
 summaryTable_tydal[1+i,"MAE"]             <- MAE

 
  # prepare dataset for next loop
 euclidDist <- sf::st_distance(depths_tydal_temp) 
 euclidDist <- units::drop_units(euclidDist)
 euclidDist[euclidDist == 0] <- NA
 distMin_tydal_temp <- rowMins(euclidDist, na.rm=T)
 
}
saveRDS(summaryTable_tydal, "Data/Tydal/tydal_cvAnalysisData.rds")

saveRDS(IDW_tydal_i30, "Output/Tydal/IDW_tydal_i30.rds")
saveRDS(IDW_tydal_i60, "Output/Tydal/IDW_tydal_i60.rds")
saveRDS(IDW_tydal_i90, "Output/Tydal/IDW_tydal_i90.rds")
```

```{r, eval=F}
# I will not bother going lower than ten data points
for(i in 1:c(nrow(depths_geilo)-10)){
  
 print(paste("run number = ", i))
  
 toRemove <- which(distMin_geilo_temp == min(distMin_geilo_temp))[1]
 print(paste("Removing row number ", toRemove))
 
 # get some stats distance between neighbours
 medianDist <- median(distMin_geilo_temp)
 meanDist   <- mean(distMin_geilo_temp)
 skewDist   <- e1071::skewness(distMin_geilo_temp)

 depths_geilo_temp <- depths_geilo_temp[-toRemove,]

 # perform interpolation on tempDF
  int <- gstat::idw(Dybde ~ 1, depths_geilo_temp, 
                    newdata=grid_Geilo_stars_crop_biggest, 
                    nmax=nmax, idp=2)
  
  # Export some predictions for checks
  if(i %in% seq(40, 240, 50)){
    assign(paste0("IDW_geilo_i", i), int)
  }
  
  
  est <- sum(int$var1.pred, na.rm=T)
  
  # get the MAE as well, even though it takes a long time to run
  MAE <- krige.cv(Dybde ~ 1, depths_geilo_temp, set = list(idp=2), nmax = nmax)
  MAE <- mean(abs(MAE$residual))
  
 # paste into the summary table
 summaryTable_geilo[1+i,"medianDist"]      <- medianDist
 summaryTable_geilo[1+i,"meanDist"]        <- meanDist
 summaryTable_geilo[1+i,"skewness"]        <- skewDist
 summaryTable_geilo[1+i,"n"]               <- length(distMin_geilo_temp)-1
 summaryTable_geilo[1+i,"estimatedPeatVolume_m3"]           <- est
 summaryTable_geilo[1+i,"MAE"]             <- MAE

 
  # prepare dataset for next loop
 euclidDist <- sf::st_distance(depths_geilo_temp) 
 euclidDist <- units::drop_units(euclidDist)
 euclidDist[euclidDist == 0] <- NA
 distMin_geilo_temp <- rowMins(euclidDist, na.rm=T)
 
}
saveRDS(summaryTable_geilo, "Data/Geilo/geilo_cvAnalysisData.rds")

saveRDS(IDW_geilo_i40, "Output/Geilo/IDW_geilo_i40.rds")
saveRDS(IDW_geilo_i90, "Output/Geilo/IDW_geilo_i90.rds")
saveRDS(IDW_geilo_i140, "Output/Geilo/IDW_geilo_i140.rds")
saveRDS(IDW_geilo_i190, "Output/Geilo/IDW_geilo_i190.rds")
saveRDS(IDW_geilo_i240, "Output/Geilo/IDW_geilo_i240.rds")

```

A code block just for getting the reduced datasets
```{r}
distMin_tydal_temp <- distMin_tydal
depths_tydal_temp <- depths_tydal

for(i in 1:c(nrow(depths_tydal)-10)){
  
 print(paste("run number = ", i))
  
 toRemove <- which(distMin_tydal_temp == min(distMin_tydal_temp))[1]
 print(paste("Removing row number ", toRemove))
 
 depths_tydal_temp <- depths_tydal_temp[-toRemove,]

  # Export some data set for checks
  if(i %in% seq(30, 90, 10)){
    assign(paste0("depths_tydal_i", i), depths_tydal_temp)
  }

 
  # prepare dataset for next loop
 euclidDist <- sf::st_distance(depths_tydal_temp) 
 euclidDist <- units::drop_units(euclidDist)
 euclidDist[euclidDist == 0] <- NA
 distMin_tydal_temp <- rowMins(euclidDist, na.rm=T)
 
}
```

```{r, fig.cap="Demonstrating the gradual reductino in sampling points."}
tmap_arrange(
tm_shape(SHP_tydal)+
  tm_polygons()+
  tm_shape(depths_tydal)+
  tm_symbols(col="black",
               shape=4,
               size = .5)+
  tm_layout(title = "All data points",
            inner.margins = c(.1,.02,.1,.02))
,
tm_shape(SHP_tydal)+
  tm_polygons()+
  tm_shape(depths_tydal_i30)+
  tm_symbols(col="black",
               shape=4,
               size = .5)+
  tm_layout(title = "-32 data points",
            inner.margins = c(.1,.02,.1,.02))
,
tm_shape(SHP_tydal)+
  tm_polygons()+
  tm_shape(depths_tydal_i60)+
  tm_symbols(col="black",
               shape=4,
               size = .5)+
  tm_layout(title = "-62 data points",
            inner.margins = c(.1,.02,.1,.02))
,
tm_shape(SHP_tydal)+
  tm_polygons()+
  tm_shape(depths_tydal_i80)+
  tm_symbols(col="black",
               shape=4,
               size = .5)+
  tm_layout(title = "-82 data points",
            inner.margins = c(.1,.02,.1,.02)))
```


```{r}
summaryTable_tydal <- readRDS("Data/Tydal/tydal_cvAnalysisData.rds")
```


## Explore results

### Sampling design

```{r, fig.cap="IDW with mean distance between data points fromleft to right: 19.4, 20.2 and 40 m"}
tmap_arrange(
tm_shape(IDW_tydal_i30)+
  tm_raster(col="var1.pred",
            palette = "-viridis",
            title = "Interpolated peat\ndepth (m)"),
tm_shape(IDW_tydal_i60)+
  tm_raster(col="var1.pred",
            palette = "-viridis",
            title = "Interpolated peat\ndepth (m)"),
tm_shape(IDW_tydal_i90)+
  tm_raster(col="var1.pred",
            palette = "-viridis",
            title = "Interpolated peat\ndepth (m)")
)
```


### Distance to neighbours 
```{r}
ggarrange(
   ggplot(data = summaryTable_tydal)+
     geom_point(aes(x = n, y = medianDist))+
     geom_point(aes(x = n, y = meanDist), pch = 21,fill="grey")+
     theme_bw()+
     ylab("Distance to nearest neighbour")+
     ggtitle("Tydal")+
     ylim(0,75),
   ggplot(data = summaryTableG)+
     geom_point(aes(x = n, y = medianDist))+
     geom_point(aes(x = n, y = meanDist), pch = 21,fill="grey")+
     theme_bw()+
     ylab("Distance to nearest neighbour")+
     ggtitle("Geilo")+
     ylim(0,200)
)
```

This figure tells us that the median (black) and the mean (grey) distance to nearest neighbor are very similar, meaning there is little skew, meaning again that the n reduction process has retained the systematic sampling design.

### skew

```{r}
ggarrange(
   ggplot(data = summaryTable_tydal)+
     geom_point(aes(x = n, y = skewness), pch = 21,fill="grey")+
     theme_bw()+
     ylab("Distance to nearest neighbour")+
     ggtitle("Tydal"),
   ggplot(data = summaryTableG)+
     geom_point(aes(x = n, y = medianDist))+
     geom_point(aes(x = n, y = meanDist), pch = 21,fill="grey")+
     theme_bw()+
     ylab("Distance to nearest neighbour")+
     ggtitle("Geilo")+
     ylim(0,200)
)
```

Contyrary to the above, this figure indicates perhaps that the sampling designs is compromised when I reduce n. It starts out with a negative skew due to some points being very close together. There are then 'weeded out' first, and the skew is flipped around to become positive.

Plot maps with varying sampling densities here!

### Peat volume estimates

```{r, fig.cap="Estimated peat volume as a response of the median distance between sampling points."}
arrange <- ggarrange(
   ggplot(data = summaryTable_tydal,
          aes(x = medianDist, y = estimatedPeatVolume_m3))+
     geom_point(
                pch=21, 
                fill="grey",
                size=2)+
     #geom_smooth(method = "loess", span=0.5, colour="grey30")+
     theme_bw(base_size = 16)+
     ylab(expression("Est. peat volume (m"^3*")"))+
     xlab("Median distance to\nnearest neighbour (m)")+
     ggtitle("Tydal")+
     coord_trans(x="log2"),
  
  
   ggplot(data = summaryTableG)+
     geom_point(aes(x = n, y = estimatedPeatVolume_m3))+
    # geom_point(aes(x = n, y = meanDist), pch = 21,fill="grey")+
     theme_bw()+
     ylab("Est. peat volume")+
     ggtitle("Geilo")+
     xlim(0,200)+
     scale_x_continuous(trans='log2')
)

ggsave("plot_best_practice_volume.png", arrange)
```

For Tydal, the estimated peat volume is quite stable up to around 30 meter between sampling points. 


### CV
In addition to seeing the peat volume estimates becoming biased with increasing distance between sampling points, we also we the variation increasing. Now we will calculate this in terms of the coefficient of variation. 

```{r}
max(summaryTable_tydal$medianDist)
```


```{r}
tydal_cv <- summaryTable_tydal
tydal_cv$group <- ifelse(
  tydal_cv$medianDist<10, "<10 m", ifelse(
    tydal_cv$medianDist<15, "10-15 m", ifelse(
     tydal_cv$medianDist<20, "15-20 m", ifelse(
       tydal_cv$medianDist<25, "20-25 m", ifelse(
         tydal_cv$medianDist<30, "25-30 m", ifelse(
           tydal_cv$medianDist<35, "30-35 m", ifelse(
             tydal_cv$medianDist<40, "35-40 m", "40-55 m")))))))
tydal_cv <- tydal_cv[tydal_cv$medianDist<100,]
(tydal_n <- table(tydal_cv$group))

```

There's quite few data points in the higher categories. Perhaps too few.

CV function
```{r}
cv <- function(x){sd(x)/mean(x)}
```


Tydal:
```{r}
#cvTable <- tapply(dat$estimatedPeatVolume_m3, dat$group, cv)
#cvTable <- data.frame(cv = cvTable,
#                      label = theMax$label,
#                      order = as.numeric(rownames(cvTable)))
#
tydal_cv_tbl <- tapply(tydal_cv$estimatedPeatVolume_m3, tydal_cv$group, cv)
tydal_cv_tbl <- data.frame(cv = tydal_cv_tbl,
                      label = names(tydal_cv_tbl),
                      order = c(3,4,5,6, 7,8))
tydal_cv_tbl <- tydal_cv_tbl[order(tydal_cv_tbl$order),]
tydal_cv_tbl$n <- tydal_n
```

```{r}
ggplot(data = tydal_cv_tbl, 
                 aes(x = order, y = cv
                     ))+
  geom_line(lty = 2)+
  geom_point(pch=21,
             size=3, 
             stroke=1.5,
             position = position_dodge(width=0.2))+
  theme_bw(base_size = 16)+
  scale_x_continuous(breaks = tydal_cv_tbl$order,
                     labels = tydal_cv_tbl$label)+
  theme(axis.text.x = element_text(angle = 90))+
  xlab("")
```

Geilo:
```{r}
#cvTableG <- tapply(datG$estimatedPeatVolume_m3, datG$group, cv)
#cvTableG <- data.frame(cv = cvTableG,
#                      label = theMaxG$label,
#                      order = as.numeric(rownames(cvTableG)))

cvTableG <- tapply(summaryTableG$estimatedPeatVolume_m3, summaryTableG$group, cv)
cvTableG <- data.frame(cv = cvTableG,
                      label = names(cvTableG),
                      order = c(1,2,3,4,5,6,7,8))
cvTableG <- cvTableG[order(cvTableG$order),]
cvTableG$n <- geiloN
```

Join tables
```{r}
cvTable$site = "Tydal"
cvTableG$site = "Geilo"
cvTab <- rbind(cvTable,
               cvTableG)
```

```{r}
cvPlot <- ggplot(data = cvTab, 
                 aes(x = order, y = cv,
                     group=site,
                     fill=site
                     ))+
  geom_line(lty = 2)+
  geom_point(pch=21,
             size=3, 
             stroke=1.5,
             position = position_dodge(width=0.2))+
  theme_bw(base_size = 16)+
  scale_x_continuous(breaks = cvTab$order,
                     labels = cvTab$label)+
  theme(axis.text.x = element_text(angle = 90))+
  xlab("")
cvPlot
ggsave("plot_best_practice_cv_nn.png", cvPlot)
#cvPlotG <- ggplot(data = cvTableG, aes(x = order, y = cv))+
#  geom_line(lty = 2)+
#  geom_point(pch=21, fill="grey",
#             size=3, stroke=1.5)+
#  theme_bw(base_size = 16)+
#  scale_x_continuous(breaks = cvTableG$order,
#                     labels = cvTableG$label)+
#  theme(axis.text.x = element_text(angle = 90))+
#  xlab("")+
#  ggtitle("Geilo")
```


## MAE

```{r}
ggplot(summaryTable_tydal,
       aes(x = medianDist, y = MAE))+
  geom_point(pch=21, 
                fill="grey",
                size=2)+
     #geom_smooth(method = "loess", span=0.5, colour="grey30")+
     theme_bw(base_size = 16)+
     ylab("Mean absolute error (m)")+
     xlab("Median distance to\nnearest neighbour (m)")+
     ggtitle("Tydal")+
     coord_trans(x="log2")
```

