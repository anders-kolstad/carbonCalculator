---
title: "Random subsetting volume and mean"
author: "MarteFandrem"
date: "22 2 2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, eval=F}

knitr::purl("Evaluating_best_practice.Rmd")

p <-NCmisc::list.functions.in.file("Evaluating_best_practice.R")
summary(p)
```


#Packages needed
```{r, echo=FALSE} 
library(readxl)
library(writexl)
library(rgdal)
library(raster)
library(gstat)
library(matrixStats)
library(units)
library(sf)
library(sp)
library(tmap)
library(dplyr)
library(rasterVis)
library(readr)

```


#Import and clean up data

```{r}

shp<-readOGR(dsn="../Data/Tydal", layer="stasjon_Setermyra")

df <- read_csv("../Data/Tydal/Torvdybder_Tydal_stasjon.csv")

# Make spatial dataframe of the peat depths points

dfs <- st_as_sf(x = df, 
                        coords = c("coords.x1", "coords.x2"),
                        crs = "+init=epsg:25833")

# Make sf file from sp shapefile
sf_shp <- st_as_sf(shp)

#Check projections
sf::st_crs(shp)
sf::st_crs(dfs)

#set same projection on all files
proj4string(shp)<-crs(dfs)

#make spatial file from data frame file
# the inerpolation requires spatial object, and cannot work with sf objects
dfsp <- as(dfs, Class="Spatial")



```

Cleaning the environment
```{r}
rm(df)
```

#Visualisere dataene

```{r, message=F, warning=F}
tmap_mode("view")
  tm_shape(sf_shp)+
  tm_polygons() +
  tm_shape(dfs)+
  tm_dots(col="Dybde", alpha=1, palette="-viridis", size=0.1 ) +
              tm_layout(legend.outside = TRUE)

```


Create grid and adjust to extent of peatland

```{r}
grid <- raster(extent(shp)) #create a raster grid from the extent of the peatland
res(grid) <- 1              #set resolution of the grid to 1x1m
proj4string(grid)<-crs(dfs) #set similar projection to the grid as to the datapoints

grid_sp <-as(grid, "SpatialPixels") #convert the grid from raster to spatialpixels

grid_sp@grid@cellsize       #check that cell size is 1x1
```
Resolution is OK, 1x1 m

Now we are cropping the extent of the raster grid
```{r}
grid_crop <- grid_sp[shp,]  #crop the grid to only include the peatland
plot(grid_crop)
```


Calculate distance between one point and all other points
```{r}
#euclidDist <- sp::spDists(dfsp,longlat = FALSE)
```

Create 3Dplot
Does not work.
```{r}
#idw <- idw(Dybde ~ 1, dfsp_station, grid_crop, nmax=8, #idp=3)
#idw_df <-as.data.frame(idw)
#x <- idw_df$x
#x1 <- sort.list(x)
#x2 <- idw_df$x[x1]
#y <- idw_df$y
#y1 <- sort.list(y)
#y2 <- idw_df$y[y1]
#z <- idw_df$var1.pred
#z <- as.matrix(data.frame(x=x,y=y))
#z <- matrix(idw_df$var1.pred)
#persp(x2, y2, z,
#      theta = 135, phi = 30,
#      col = "brown", scale = FALSE,
#    ltheta = -120, shade = 0.75,
#      border = NA, box = FALSE)
```
Create 3D-plot 2.
Trouble with packages
```{r}
#idw_r <- raster(idw)
#plot3D(idw_r)
```


# Boostrapping for CV estimation

What do I want to do?
- Resample the dataset with increasing distance between points.
- Interpolate to get volume 
- Run this 100 - 1000 times per step and calculate the coefficient of variance CV for each step


# Subset data 
by gradually removing the closest point 


```{r}
euclidDist <- sf::st_distance(dfs) 
euclidDist <- units::drop_units(euclidDist)
euclidDist[euclidDist == 0] <- NA
dist <- rowMins(euclidDist, na.rm=T)
```

```{r}
dist2 <- dist
tempDF <- dfs

for(i in 1:nrow(dfs)-5){
  
  print(paste("run number = ", i))
  
 toRemove <- which(dist2 == min(dist2))[1]
 print(paste("Removing row number ", toRemove))
 dist2 <- dist2[-toRemove]
 
 tempDF <- tempDF[-toRemove,]
 
 # perform interpolation on tempDF
 
 euclidDist <- sf::st_distance(tempDF) 
 euclidDist <- units::drop_units(euclidDist)
 euclidDist[euclidDist == 0] <- NA
 dist2 <- rowMins(euclidDist, na.rm=T)
 
 print(paste("length dist2 =", length(dist2)))
}


```

```{r}



for(i in 1:nrow(mtcars)) ifelse(i==7,break(),mc[[i]]<-mtcars[-(1:i),])

dataList = list()
for (i in seq(1, 10)){
    dataList[[i]] = mtcars[i:nrow(mtcars),]
}
```



#Interpolate all the various models and get the volume
```{r, echo=FALSE}
neighbors = length(dfsp_station$Dybde)
power = c(seq(from = 1, to = 4, by = 1))
neigh = c((1), seq(2,30,by = 2), c(length=(neighbors)))

temp <- data.frame()

for (i in power) {
  for (j in neigh) {
    
    temp2 <- NULL
    temp3 <- NULL
    temp4 <- NULL

    run = paste(i, j, sep="_")

    print(run)
    temp2 <- idw(Dybde ~ 1, dfsp_station, grid_crop, nmax=j, idp=i)
    temp3 <- as.data.frame(temp2@data)
    temp4 <- sum(temp3$var1.pred)
    temp5 <- cbind(run, temp4)
    temp  <- rbind(temp, temp5)
  }
} 

max <- max(volume$volume)
min <- min(volume$volume)
mean <- mean(volume$volume)
sd <- sd(volume$volume)


Description <- c("mean", "min", "max", "SD")
Results_volume <- data.frame(Description, Results = c(mean, min, max, sd)) 

```

```{r}
volume <- temp
volume <-dplyr::rename(volume, volume=temp4)
volume <- tidyr::separate(volume, 
                        run, 
                        into = c("power", "nn"),
                        sep = "_",
                        remove=F)
volume$power <- as.numeric(volume$power)
volume$nn <- as.numeric(volume$nn)
volume$volume <- as.numeric(volume$volume)

```

#Values for printing (mean, min, max, SD)
```{r}
max <- max(volume$volume)
min <- min(volume$volume)
mean <- mean(volume$volume)
sd <- sd(volume$volume)


Description <- c("mean", "min", "max", "SD")
Results_volume <- data.frame(Description, Results = c(mean, min, max, sd)) 

Results_volume
```

#Volume from area and mean
```{r}
area <- st_area(sf_shp)
```

```{r}
mean <- mean(dfsp_station$Dybde)
```

```{r}
roughvol <- mean*area
roughvol

```

