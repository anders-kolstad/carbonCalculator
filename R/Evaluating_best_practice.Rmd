---
title: "Random subsetting volume and mean"
author: "MarteFandrem"
date: "22 2 2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, eval=F}

knitr::purl("Evaluating_best_practice.Rmd")

p <-NCmisc::list.functions.in.file("Evaluating_best_practice.R")
summary(p)
```


#Packages needed
```{r, echo=FALSE} 
library(readxl)
library(writexl)
library(e1071)
library(rgdal)
library(raster)
library(gstat)
library(matrixStats)
library(units)
library(sf)
library(sp)
library(tmap)
library(dplyr)
library(rasterVis)
library(readr)

```


#Import and clean up data

```{r}

shp<-readOGR(dsn="../Data/Tydal", layer="stasjon_Setermyra")

df <- read_csv("../Data/Tydal/Torvdybder_Tydal_stasjon.csv")

# Make spatial dataframe of the peat depths points

dfs <- st_as_sf(x = df, 
                        coords = c("coords.x1", "coords.x2"),
                        crs = "+init=epsg:25833")

# Make sf file from sp shapefile
sf_shp <- st_as_sf(shp)

#Check projections
sf::st_crs(shp)
sf::st_crs(dfs)

#set same projection on all files
proj4string(shp)<-crs(dfs)

#make spatial file from data frame file
# the inerpolation requires spatial object, and cannot work with sf objects
dfsp <- as(dfs, Class="Spatial")



```

Cleaning the environment
```{r}
rm(df)
```

#Visualisere dataene

```{r, message=F, warning=F, out.width = '80%'}
tmap_mode("view")
  tm_shape(sf_shp)+
  tm_polygons() +
  tm_shape(dfs)+
  tm_dots(col="Dybde", alpha=1, palette="-viridis", size=0.1 ) +
              tm_layout(legend.outside = TRUE)

```


Create grid and adjust to extent of peatland

```{r}
grid <- raster(extent(shp)) #create a raster grid from the extent of the peatland
res(grid) <- 1              #set resolution of the grid to 1x1m
proj4string(grid)<-crs(dfs) #set similar projection to the grid as to the datapoints

grid_sp <-as(grid, "SpatialPixels") #convert the grid from raster to spatialpixels

grid_sp@grid@cellsize       #check that cell size is 1x1
```
Resolution is OK, 1x1 m

Now we are cropping the extent of the raster grid
```{r}
grid_crop <- grid_sp[shp,]  #crop the grid to only include the peatland
plot(grid_crop)
```


Calculate distance between one point and all other points
```{r}
#euclidDist <- sp::spDists(dfsp,longlat = FALSE)
```

Create 3Dplot
Does not work.
```{r}
#idw <- idw(Dybde ~ 1, dfsp_station, grid_crop, nmax=8, #idp=3)
#idw_df <-as.data.frame(idw)
#x <- idw_df$x
#x1 <- sort.list(x)
#x2 <- idw_df$x[x1]
#y <- idw_df$y
#y1 <- sort.list(y)
#y2 <- idw_df$y[y1]
#z <- idw_df$var1.pred
#z <- as.matrix(data.frame(x=x,y=y))
#z <- matrix(idw_df$var1.pred)
#persp(x2, y2, z,
#      theta = 135, phi = 30,
#      col = "brown", scale = FALSE,
#    ltheta = -120, shade = 0.75,
#      border = NA, box = FALSE)
```
Create 3D-plot 2.
Trouble with packages
```{r}
#idw_r <- raster(idw)
#plot3D(idw_r)
```


# Boostrapping for CV estimation

What do I want to do?
- Resample the dataset with increasing distance between points.
- Interpolate to get volume 
- Run this 100 - 1000 times per step and calculate the coefficient of variance CV for each step


# Subset data 
by gradually removing the closest point 


```{r}
euclidDist <- sf::st_distance(dfs) 
euclidDist <- units::drop_units(euclidDist)
euclidDist[euclidDist == 0] <- NA
dist <- rowMins(euclidDist, na.rm=T)
```


Set power function and the number of nearest neighbours to consider in the inerpolation
```{r}
power <- 3
neigh <- 8 # all the closest point in a systematic grid
```

Create temperarary working files
```{r}
dist2 <- dist
tempDF <- dfs
tempDF2 <- as(tempDF, Class="Spatial")
```

Perform the first interpolation using all the points
```{r}
int <- gstat::idw(Dybde ~ 1, tempDF2, grid_crop, nmax=neigh, idp=power)
```

Get the summed volume
```{r}
(est <- sum(int@data$var1.pred))
```
Get the median distance to the closest neighougbour
```{r}
(medianDist <- median(dist2))
```
... and the mean distance

```{r}
(meanDist <- mean(dist2))
```
... and the skewness
```{r}
(skewDist <- e1071::skewness(dist2))
```
A negative skewness means the mean is smaller than the median (i.e. a right skew)

Put it into a dataframe
```{r}
(summaryTable <- data.frame(
  medianDistanceBetweenPoints        = medianDist,
  meanDistanceBetweenPoints          = meanDist,
  skewness                           = skewDist,
  totalNumberOfDepthMeasurements     = length(dist2),
  estimatedPeatVolume_m3                 = est
))
```


Perform a for-loop to gradually remove points based on how close they are to other points. This will retain most of the systematic design of the points (avoiding clumping of points)
```{r}
for(i in 1:c(nrow(dfs)-1)){
  
 print(paste("run number = ", i))
  
 toRemove <- which(dist2 == min(dist2))[1]
 print(paste("Removing row number ", toRemove))
 
 # get some stats distance between neighbours
 medianDist <- median(dist2)
 meanDist   <- mean(dist2)
 skewDist   <- e1071::skewness(dist2)

 #dist2 <- dist2[-toRemove]
 
 tempDF <- tempDF[-toRemove,]
 tempDF2 <- as(tempDF, Class="Spatial")
 

 # perform interpolation on tempDF
  int <- gstat::idw(Dybde ~ 1, tempDF2, grid_crop, nmax=neigh, idp=power)
  est <- sum(int@data$var1.pred)
  
 # paste into the summary table
 summaryTable[1+i,"medianDistanceBetweenPoints"]      <- medianDist
 summaryTable[1+i,"meanDistanceBetweenPoints"]        <- medianDist
 summaryTable[1+i,"skewness"]                         <- skewDist
 summaryTable[1+i,"totalNumberOfDepthMeasurements"]   <- length(dist2)-1
 summaryTable[1+i,"estimatedPeatVolume_m3"]           <- est

 
  # prepare dataset for next loop
 euclidDist <- sf::st_distance(tempDF) 
 euclidDist <- units::drop_units(euclidDist)
 euclidDist[euclidDist == 0] <- NA
 dist2 <- rowMins(euclidDist, na.rm=T)
 
}


```



