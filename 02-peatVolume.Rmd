# Peat volume
We want to intrapolate values from the depth measurement only a raster grid. From this we can estimate the total volume of the peatland, and also visualise the depth profiles.

## Raster grid
Create raster grid based on the extent of the peatland
```{r}
#Create empty raster grid (stars object) based on the extent of the peatland shape files. Resolution 1 = 1 m (becasue crs is UTM)
grid_Tydal_stars <- starsExtra::make_grid(SHP_tydal, 1)
grid_Geilo_stars <- starsExtra::make_grid(SHP_geilo, 1)
```

Visualise the grid
```{r, fig.cap="A 1x1 m raster grid in grey, overlayed with the peatland delineation in yellow."}
# To plot the grid we can convert the stars objects to sf. That way we can plot as polygons and visualise the individual cells.
# This takes too long to perform for Geilo, but we can do it for Tydal:
grid_Tydal_sf <- st_as_sf(grid_Tydal_stars)

tm_shape(grid_Tydal_sf)+
  tm_polygons()+
  tm_shape(SHP_tydal)+
  tm_polygons(col="yellow",
              alpha=.5)
```

```{r, fig.cap="Preview of the cropped raster grids.", warning=F, message=F}
grid_Tydal_stars_crop <- sf::st_crop(grid_Tydal_stars, SHP_tydal)
grid_Geilo_stars_crop <- sf::st_crop(grid_Geilo_stars, SHP_geilo)

tmap_arrange(
tm_shape(grid_Geilo_stars_crop)+
  tm_raster(palette = "blue")+
  tm_layout(title = "Geilo",
            legend.show = F),
tm_shape(grid_Tydal_stars_crop)+
  tm_raster(palette = "red")+
  tm_layout(title = "Tydal",
            legend.show = F))

```

## Inverse distance weighting
We chose to use IDW for the interpolation. This is because we do not want to include a separate step with for example calculating a variogram. 

The IDW requires setting the number of neighbouring points to consider. We set this to consider all points in the dataset.
IDW also has a power parameter, and this is where we can tune the results by down-weighting datapoints that are further away.
Let's do a test with power equals 2 and power equals 3.
```{r}
library(gstat)

myPowers <- 1:10
for(i in myPowers){
  temp <- gstat::idw(formula = Dybde ~ 1, 
           locations = depths_tydal, 
           newdata = grid_Tydal_stars_crop, 
           idp=i)
  assign(paste0("IDW_tydal_", i), temp)
}



```

What do these models look like
```{r, fig.cap="First view of how IDW models look like depending on the power parameter. Test site: Tydal."}
for(i in myPowers){
  
  temp <- get(paste0("IDW_tydal_", i))
  
  temp <- tm_shape(temp)+
    tm_raster(col="var1.pred",
            palette = "-viridis",
            title = "Interpolated peat\ndepth (m)")+
    tm_layout(legend.outside = T,
            title = paste0("Power = ", i))
  assign(paste0("tmap_IDW_tydal_power_", i), temp)
}



tmap_arrange(
  tmap_IDW_tydal_power_1,
  tmap_IDW_tydal_power_2,
  tmap_IDW_tydal_power_4,
  tmap_IDW_tydal_power_6,
  tmap_IDW_tydal_power_8,
  tmap_IDW_tydal_power_10,
ncol = 3)

```

Let's check the fit with a plot of the residuals.
```{r}
# Get the predicted values

resids_tydal <- data.frame(run = 1:nrow(depths_tydal))

for(i in myPowers){
  temp <- get(paste0("IDW_tydal_", i))
  fit  <- stars::st_extract(temp, depths_tydal)
  resids_tydal[,i+1] <- fit$var1.pred
}


resids_tydal <- tidyr::pivot_longer(resids_tydal,
                                    !run,
                                    names_to = "power",
                                    values_to = "residual")

# Remove V from column names
resids_tydal$power <- gsub(pattern = "V", 
                           replacement = "",
                           x = resids_tydal$power)

resids_tydal$power <- as.numeric(resids_tydal$power)
resids_tydal$power <- resids_tydal$power-1


ggplot(resids_tydal, aes(x=factor(power), y = residual))+
  geom_violin(fill="grey",
              trim=F)+
  theme_bw(base_size = 12)

```

These residuals don't seem to depends at all on whether we have a smooth ar detailed model.

What about the estimated volume - does that change?
```{r}
volume_tydal <- NULL
for(i in myPowers){
  temp <- get(paste0("IDW_tydal_", i))
  volume_tydal <- c(volume_tydal,
                    sum(temp$var1.pred, na.rm = T))
}

```

```{r}
volume_tydal <- data.frame("volume" = volume_tydal,
                              "power" = myPowers)
ggplot(volume_tydal, aes(x = factor(power), y = volume))+
  geom_point(size=10)+
  xlab("power")+
  theme_bw(base_size = 12)
```


But what if we do leave one out cross validation
```{r}
#for(i in myPowers){
#  temp <- krige.cv(Dybde ~ 1, depths_tydal, set = list(idp=i))
#}
#cv_tydal_power_1 <- 
#
#test <- stars::st_extract(IWD_tydal_1, depths_tydal)
#
#mean(abs(depths_tydal$Dybde-test$var1.pred))
#mean(abs(cv_tydal_power_1$residual))
#
#
#depths_tydal$fit_power_1 <- fit$var1.pred
#depths_tydal$fit_power_1 - depths_tydal
```

